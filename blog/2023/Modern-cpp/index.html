<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Modern C++ 문법 정리 | Seojune Lee</title> <meta name="author" content="Seojune Lee"> <meta name="description" content="C++11 이상에서 새로 도입된 대표적인 modern c++ 문법"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700%7CRoboto+Slab:100,300,400,500,700%7CMaterial+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https:/vantaa89.github.io//blog/2023/Modern-cpp/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Seojune </span>Lee</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Modern C++ 문법 정리</h1> <p class="post-meta">January 13, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/data-structure"> <i class="fas fa-hashtag fa-sm"></i> data-structure</a>   </p> </header> <article class="post-content"> <p>C++은 C++98 이후로 굉장히 오랫동안 정체되어 있다가, C++11 업데이트에서 많은 기능이 새로 도입되었다. 이 때문에 C++11 이후의 업데이트인 C++14, C++17, C++20 등을 <strong>모던 C++</strong>이라고 따로 지칭한다. 평소 알고리즘 문제를 풀 떄 정도는 modern C++ 기능들을 알 필요가 별로 없어서 따로 공부할 생각을 하지 않았지만 중요한 몇 개는 알고 있어야 할 것 같아서 정리해본다.</p> <h1 id="auto와-decltype"> <code class="language-plaintext highlighter-rouge">auto</code>와 <code class="language-plaintext highlighter-rouge">decltype</code> </h1> <h2 id="auto"><code class="language-plaintext highlighter-rouge">auto</code></h2> <p>변수를 선언할 때, 모던 C++에서는 특정 경우 자료형을 따로 지정하지 않아도 알아서 자료형을 추론한다. 단, 선언과 동시에 변수가 초기화되어야 한다. 그러지 않으면 자료형을 알 수가 없기 떄문이다.</p> <pre><code class="language-C++">auto var1 = 100;        // int
auto var2 = 100L;       // long
auto var3 = 100.0;      // double
auto var4 = "string";   // string
auto var5; //ERROR!
</code></pre> <p>특히 iterator와 같은 것들을 귀찮게 적어줄 필요가 없어졌다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vector&lt;int&gt; a;
// 기존
vector&lt;int&gt;::iterator it = a.begin();
// 모던 C++
auto it = a.begin();
</code></pre></div></div> <h2 id="decltype"><code class="language-plaintext highlighter-rouge">decltype</code></h2> <p><code class="language-plaintext highlighter-rouge">decltype</code>은 함수처럼 사용되어서 감싸고 있는 표현의 타입을 알려준다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>     <span class="c1">// int</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>      <span class="c1">// int</span>

<span class="kt">int</span><span class="o">&amp;</span> <span class="n">r_a</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">r_a</span><span class="p">)</span> <span class="n">r_b</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>  <span class="c1">// int&amp;</span>
</code></pre></div></div> <p>값이 아닌 표현이 들어갈 경우에는 조금 더 복잡해지는데, 여기에 대해서는 이후에 추가하겠다.</p> <h1 id="range-based-loop">range-based loop</h1> <p>아마 파이썬에서 영향을 받아온 것 같다. 파이썬에서는</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</code></pre></div></div> <p>처럼 iterable의 원소들을 하나씩 가져와서 매우 쉽게 사용할 수 있다. 기존 C++에서는 이를 위해서는 귀찮게 <code class="language-plaintext highlighter-rouge">iterator</code>를 사용해야 했다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span>
<span class="nf">for</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>하지만 Modern C++에서는 python과 같은 range-based loop를 사용할 수 있다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">e</span><span class="o">:</span> <span class="n">v</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>값을 복사하는 대신 reference를 사용해 가져올 수도 있다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"modern"</span><span class="p">,</span> <span class="s">"C++"</span><span class="p">};</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">e</span><span class="o">:</span> <span class="n">v</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>C++17부터는 pair로 이루어진 list를 아래와 같이 풀어서 쓸 수도 있다. 점점 파이썬과 비슷해지는 것 같다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">),</span> <span class="n">make_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">"modern"</span><span class="p">),</span> <span class="n">make_pair</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="s">"C++"</span><span class="p">)};</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">st</span><span class="p">]</span><span class="o">:</span> <span class="n">v</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">st</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h1 id="람다-함수">람다 함수</h1> <p>파이썬에서처럼 람다 함수(익명 함수)를 사용할 수 있게 되었다. 예를 들어서, 파이썬에서는 다음과 같은 표현이 가능했다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="c1"># 5
</span></code></pre></div></div> <p>특히 이는 내장 함수의 파라미터로 다른 함수가 들어가는 경우에 유용하게 사용할 수 있었다. 예를 들어서 정렬을 할 때, 우리가 정한 함수의 기준으로 정렬을 하고 싶을 수 있다. 그럴 때 우리는 이렇게 써줄 수 있었다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sorted_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">some_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">%</span><span class="mi">12</span><span class="p">)</span>
</code></pre></div></div> <p>이 예시에서 sorted라는 내장함수는 key라는 함수를 받아서, 그 함수가 작은 순서대로 정렬을 하게 된다. 여기에서 굳이 함수를 이름붙여주고 <code class="language-plaintext highlighter-rouge">def</code>를 사용해 정의하기보다 저렇게 inline으로 써주는 것이 훨씬 간단하다. 마찬가지로 C++에서도 람다 함수를 사용할 수 있다. 다만 문법은 조금 다르다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">};</span>
<span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>    <span class="c1">// 7</span>
</code></pre></div></div> <p>각 부분의 의미를 살펴보면 이렇다.</p> <ul> <li>[]: 캡처. 안에 들어가는 이름의 외부변수를 복사하거나 참조해온다.</li> <li>(): 매개변수</li> <li>{}: 함수의 동작</li> </ul> <p>또한, <code class="language-plaintext highlighter-rouge">f</code>의 타입이 auto로 자동결정되는 것을 알 수 있는데 사실 <code class="language-plaintext highlighter-rouge">f</code>의 타입은 함수 포인터로, <code class="language-plaintext highlighter-rouge">void (*f)(int a, int b)</code>와 같은 형식이 된다. 이를 굳이 적어주기는 번거로우니 <code class="language-plaintext highlighter-rouge">auto</code>를 사용하면 된다.</p> <p>매개변수와 함수의 동작은 기존 함수와 다를 것이 없다. C++의 람다 함수에서 처음 나오는 개념은 캡처라는 것이다. 이는 함수 외부에서 정의된 상수나 변수를 람다 함수 안에서 사용해주기 위해서 적어주는 것이다. 예를 들어서 다음과 같이 사용할 수 있다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">val1</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">val2</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val1</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">val2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span>  <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">val1</code>과 <code class="language-plaintext highlighter-rouge">val2</code>를 복사하지 않고 reference를 통해 가져오는 것도 가능하다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">val1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val2</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val1</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">val2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span>  <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>만약 모든 변수를 가져오고 싶다면 다음과 같이 하면 된다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>                <span class="c1">// 모든 변수를 복사해서 가져온다</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val1</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">val2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span>  <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>                <span class="c1">// 모든 변수를 reference로 가져온다</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val1</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">val2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span>  <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h1 id="스마트-포인터">스마트 포인터</h1> <p>C++11에서는 <code class="language-plaintext highlighter-rouge">std::auto_ptr</code>이 처음 도입되었지만, 이는 더 이상 사용되지 않는다. 대신 <code class="language-plaintext highlighter-rouge">std::unique_ptr</code>, <code class="language-plaintext highlighter-rouge">std::shared_ptr</code>, <code class="language-plaintext highlighter-rouge">std::weak_ptr</code>가 도입되었다. 이는 러스트에서 사용하는 소유권의 개념과도 매우 비슷하다.</p> <h2 id="stdunique_ptr"><code class="language-plaintext highlighter-rouge">std::unique_ptr</code></h2> <p><code class="language-plaintext highlighter-rouge">unique_ptr</code>은 기존 포인터와 달리, 가리키는 대상을 자신이 “소유”하는 것으로 볼 수 있다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="c1">// 또는</span>
<span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="k">new</span> <span class="kt">int</span> <span class="p">{</span><span class="mi">5</span><span class="p">}};</span>

<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 5</span>
</code></pre></div></div> <p>위와 같이 정의해주면 <code class="language-plaintext highlighter-rouge">a</code>는 이름에 맞게 5를 가리키는 “유일한 포인터”가 된다. 즉 <code class="language-plaintext highlighter-rouge">a</code>를 통하지 않고는 5에 접근할 수가 없다. 즉 아래와 같이 <code class="language-plaintext highlighter-rouge">a</code>를 복사하는 것이 불가능하다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>     <span class="c1">// compile error</span>
</code></pre></div></div> <p>왜냐하면 <code class="language-plaintext highlighter-rouge">a</code>만이 5를 가리키는 유일한 포인터여야 하기 때문이다. 대신 소유권을 이전할 수는 있는데, 그러면 <code class="language-plaintext highlighter-rouge">a</code>로는 더 이상 5에 접근할 수 없게 된다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</code></pre></div></div> <h2 id="stdshared_ptr"><code class="language-plaintext highlighter-rouge">std::shared_ptr</code></h2> <p>Shared pointer의 경우 reference count 방식으로 메모리를 관리한다. 이름에서 알 수 있듯이, <code class="language-plaintext highlighter-rouge">unique_ptr</code>와는 달리 여러 포인터가 한 객체를 가리키는 것이 가능하다. 여기에서 reference count라는 말은, 특정 객체를 가리키는 포인터의 개수를 세고 있다가 0이 되는 순간 메모리를 해제해준다는 뜻이다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>        <span class="c1">// 5 5</span>
</code></pre></div></div> <p>한편, reference counter 방식의 포인터는 <a href="/blog/2023/Rust-Pointer/">이 링크</a>에서 설명해두었듯이 두 포인터가 서로를 참조하는 경우 영원히 메모리에서 삭제되지 않게 된다. 이를 방지하기 위해서 <code class="language-plaintext highlighter-rouge">std::weak_ptr</code>를 함께 사용해준다.</p> </article><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"alshedivat/al-folio","data-repo-id":"MDEwOlJlcG9zaXRvcnk2MDAyNDM2NQ==","data-category":"Comments","data-category-id":"DIC_kwDOA5PmLc4CTBt6","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,a])=>giscusScript.setAttribute(t,a)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Seojune Lee. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>