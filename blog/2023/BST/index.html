<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>이진검색트리와 AVL 트리 | Seojune Lee</title> <meta name="author" content="Seojune Lee"> <meta name="description" content="이진검색트리와 AVL 트리의 삽입, 검색, 삭제 알고리즘과 그 구현"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700%7CRoboto+Slab:100,300,400,500,700%7CMaterial+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https:/vantaa89.github.io//blog/2023/BST/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Seojune </span>Lee</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">이진검색트리와 AVL 트리</h1> <p class="post-meta">January 13, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/data-structure"> <i class="fas fa-hashtag fa-sm"></i> data-structure</a>   </p> </header> <article class="post-content"> <h1 id="이진검색트리">이진검색트리</h1> <p>AVL 트리를 이해하려면 먼저 이진검색트리(Binary Search Tree)를 알아야 한다. 이진검색트리는 다음의 성질을 만족하는 트리이다.</p> <ul> <li>각 노드는 key와 value값을 하나씩 갖는다. 각 노드의 key값은 모두 서로 다르다.</li> <li>각 노드는 자식이 최대 2개이다.</li> <li>임의의 노드에 대해, 왼쪽 서브트리의 노드들은 모두 key값이 자신보다 작고 오른쪽 서브트리의 노드들은 모두 key값이 자신보다 크다.</li> </ul> <p>key와 value를 대응시키는 표같은 것이 있다고 할 때, 이진 검색 트리를 사용하지 않고 그냥 리스트 형태로 저장해놓는다면 임의의 key값에 대응되는 value를 찾기 위해 \(O(n)\)의 시간이 걸릴 것이다. 반면 BST를 사용하면 이진검색으로 \(\Theta(\lg n)\)만에 검색이 가능하다.</p> <p>이진검색트리를 시뮬레이션해보는 사이트가 있다. <a href="https:#www.cs.usfca.edu/~galles/visualization/BST.html">이 링크</a>에서 실제 BST의 삽입/삭제/검색을 시뮬레이션해보면 알고리즘을 더욱 잘 이해할 수 있을 것이다.</p> <p align="center" style="color:gray"> <img src="/assets/img/BST/bst_1.png" width="50%"> <br> 이진검색트리의 예시 </p> <h2 id="이진검색트리의-검색-삽입-삭제">이진검색트리의 검색, 삽입, 삭제</h2> <p>이진검색트리의 경우 검색과 삭제, 삽입을 모두 재귀적으로 구현할 수 있다.</p> <h3 id="검색">검색</h3> <p>검색의 경우 구현이 직관적이다. 어떤 노드를 루트로 하는 서브트리에서 key값을 가진 노드를 찾는다고 하자. 만약 현재의 노드가 찾는 key값보다 큰 key를 가지고 있다면 찾고있는 노드는 (만약 있다면) 왼쪽 서브트리에 있을 것이다. 반대로 현재 노드가 타겟의 key값보다 작은 key를 가지고 있다면 오른쪽 서브트리에서 검색을 재귀적으로 이어나가면 된다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">null</span> <span class="o">|</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> 
        <span class="k">return</span> <span class="n">node</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
</code></pre></div></div> <h3 id="삽입">삽입</h3> <p>삽입의 경우에도 큰 틀에서는 삽입과 유사하게 구현할 수 있다. 그런데, 검색과는 달리 삽입의 경우에는 트리의 구조가 바뀔 수 있기 때문에 약간의 수정이 필요하다. <code class="language-plaintext highlighter-rouge">insert(node, key, value)</code>라는 함수가 <code class="language-plaintext highlighter-rouge">node</code>를 루트로 하는 서브트리에 <code class="language-plaintext highlighter-rouge">(key, value)</code>라는 노드를 매다는 역할을 하는 함수라고 생각해보자. 단순히 생각해서, <code class="language-plaintext highlighter-rouge">search</code>의 방식을 그대로 따라하면 다음과 같이 구현이 가능할 것이다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span> 
        <span class="c1"># 현재 노드의 부모 노드에 `Node(key, value)`를 매단다
</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span>   <span class="c1"># key가 이미 존재하면
</span>        <span class="n">node</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>      <span class="c1"># value를 덮어쓴다
</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</code></pre></div></div> <p>그런데, <code class="language-plaintext highlighter-rouge">insert</code>의 입장에서는 <code class="language-plaintext highlighter-rouge">node</code>의 부모 노드를 알 수 있는 방법이 없다. 이에 대한 해결방법으로, <code class="language-plaintext highlighter-rouge">insert(node, key, value)</code>가 “삽입 후 해당 서브트리의 새로운 root”를 리턴하게 하는 방법이 있다. <code class="language-plaintext highlighter-rouge">node</code>를 루트로 하는 서브트리에 새로운 원소를 집어넣었을 때, <code class="language-plaintext highlighter-rouge">node</code>가 더 이상 그 서브트리의 root가 아니게 될 수도 있으므로 새로 바뀐 root를 함께 리턴해주는 것이다. 이 아이디어는 이후 삭제 알고리즘과 AVL 트리에서도 계속 써먹게 된다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>           <span class="c1"># 현재 노드가 null이면
</span>        <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_node</span>         <span class="c1"># 새로운 노드를 만들고 그것을 root로 삼는다
</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span>   <span class="c1"># key가 이미 존재하면
</span>        <span class="n">node</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>      <span class="c1"># value를 덮어쓴다
</span>        <span class="k">return</span> <span class="n">node</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
        <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>
    <span class="k">else</span>
        <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>
</code></pre></div></div> <h3 id="삭제">삭제</h3> <p>마찬가지 아이디어로 <code class="language-plaintext highlighter-rouge">delete(node, key)</code>를 구현한다. 삭제를 할 때는 삭제할 타겟에 세 가지 경우가 있을 것이다.</p> <ol> <li>자식 노드가 없는 경우 <ul> <li>타겟 노드를 지워주기만 하면 끝이다.</li> </ul> </li> <li>자식 노드가 하나인 경우 <ul> <li>타겟 노드를 지우고, 그 자리는 타겟 노드의 자식이 대신한다.</li> </ul> </li> <li>자식 노드가 둘인 경우 <ul> <li>이 경우가 조금 복잡해진다.</li> </ul> </li> </ol> <p align="center" style="color:gray"> <img src="/assets/img/BST/bst_2.png" width="50%"> </p> <p>예를 들어서 위 그림에서 0023을 제거하려는 경우를 생각해보자. 0023을 제거한 후, 이 자리에 다른 노드를 옮겨놓았을 때도 이진검색트리의 성질이 깨지지 않아야 한다. 그러한 노드는 딱 두 개가 있다. <strong>왼쪽 서브트리에서 가장 큰 원소</strong>(여기서는 0022), 그리고 <strong>오른쪽 서브트리에서 가장 작은 원소</strong>(여기서는 0024)이다. 둘 중 하나를 찾아서 원래 노드의 위치에 넣으면 끝이다.</p> <p align="center" style="color:gray"> <img src="/assets/img/BST/bst_3.png" width="50%"><br> 0023을 삭제하였을 때. 여기에서는 왼쪽 서브트리의 최대 노드인 0022를 0023의 자리로 가져왔다. </p> <p>이를 슈도코드로 구현하면 다음과 같다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">delete</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">delete_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
        <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">delete_node</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>
    <span class="k">else</span> <span class="c1"># key &gt; node.key
</span>        <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">delete_node</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>

<span class="n">delete_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>  <span class="c1"># node를 지우고, 기존 node자리에 오는 새로운 노드를 리턴
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">null</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">null</span>                 <span class="c1"># 기존 node의 자리에는 아무것도 없게 됨
</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>     <span class="c1"># 오른쪽 자식만 존재
</span>        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>    <span class="c1"># 왼쪽 자식만 존재
</span>        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
    <span class="k">else</span>                            <span class="c1"># 두 자식이 모두 존재
</span>       <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">max_left</span><span class="p">)</span> <span class="o">=</span> <span class="n">take_max</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="p">(</span><span class="n">max_left</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">max_left</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>   <span class="c1"># max_left를 node의 원래 위치에 놓기
</span>       <span class="k">return</span> <span class="n">max_left</span>

<span class="n">take_max</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>            <span class="c1"># node의 서브트리의 최대 노드를 찾아서, 부모 노드와 연결 끊고 리턴
</span>    <span class="c1"># 리턴 형식: (새로운 root, 삭제된 노드)
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>     <span class="c1"># 현재 노드가 최대
</span>        <span class="k">return</span> <span class="p">(</span><span class="n">null</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
    <span class="k">else</span>                        <span class="c1"># key 값이 더 큰 노드가 있음
</span>        <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">deleted_node</span><span class="p">)</span> <span class="o">=</span> <span class="n">take_max_left</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">deleted_node</span><span class="p">)</span>
</code></pre></div></div> <h1 id="avl-트리">AVL 트리</h1> <p>이진검색트리는 평균적으로는 \(\Theta(\lg n)\)만에 검색이 가능하지만, 다음과 같이 트리의 균형이 무너진 최악의 경우에는 선형의 시간복잡도를 가지게 된다. 이런 경우에는 이진검색트리를 만든 의미가 전혀 없어지게 된다.</p> <p align="center" style="color:gray"> <img src="/assets/img/BST/bst_4.png" width="50%"><br> 35, 23, 22, 10, 5를 차례대로 삽입한 경우. 이런 경우 검색, 삽입, 삭제 모두 시간복잡도가 O(n)이 된다. </p> <p>이를 해결하기 위해서 <strong>균형검색트리</strong>를 사용한다. 삽입이나 삭제 시에 트리의 구조를 바꿔서 트리가 계속 균형을 유지하도록 하는 것이다. <strong>AVL 트리</strong>는 Adelson-Velskii와 Landis가 고안한 것으로, 균형검색트리의 대표적인 예시이다. AVL 트리가 되기 위한 조건은 다음과 같다.</p> <ul> <li>이진검색트리여야 한다</li> <li>각 노드의 왼쪽 서브트리의 깊이와 오른쪽 서브트리의 깊이가 최대 1만큼 차이나야 한다.</li> </ul> <p>“깊이”라는 특징을 빠르게 계산하기 위해, 각 노드는 이제 <code class="language-plaintext highlighter-rouge">left</code>, <code class="language-plaintext highlighter-rouge">right</code> 이외에도 <code class="language-plaintext highlighter-rouge">height</code>라는 변수를 하나 더 가지게 된다. 이는 바뀔 때마다 새로 업데이트해줘야 한다. 편의상 <code class="language-plaintext highlighter-rouge">null.height == 0</code>이라고 가정한다.</p> <p><a href="https:#www.cs.usfca.edu/~galles/visualization/AVLtree.html">이 사이트</a>에서 AVL 트리의 삽입, 삭제, 검색을 테스트해볼 수 있다.</p> <h2 id="트리의-좌회전과-우회전">트리의 “좌회전”과 “우회전”</h2> <p>AVL 트리는 균형이 깨진 것을 고치기 위해서 “회전”이라는 것을 사용한다. 이를 기본 도구로 해서 삽입과 삭제 시에 균형을 맞춘다.</p> <p align="center" style="color:gray"> <img src="/assets/img/BST/bst_5.png" width="70%"> <br> 트리의 "좌회전"과 "우회전" </p> <p>예시로 좌회전을 슈도코드로 구현해보면 다음과 같다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rotate_left</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">new_root</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>
    <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">new_root</span><span class="p">.</span><span class="n">left</span>
    <span class="n">new_root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">node</span>
    <span class="n">node</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
    <span class="n">new_root</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">new_root</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">new_root</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_root</span>
</code></pre></div></div> <h2 id="트리의-균형-맞추기">트리의 균형 맞추기</h2> <p>이제 좌회전과 우회전을 어떤 경우에 적용해서 균형을 맞춰야하는지 생각해봐야 한다. 우선, <strong>balance factor</strong>라는 것을 정의한다.</p> <blockquote> <p><strong>balance factor</strong>는 왼쪽 서브트리의 높이에서 오른쪽 서브트리의 높이를 뺀 것이다.</p> </blockquote> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">balance_factor</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="o">-</span><span class="n">height</span>
</code></pre></div></div> <p>AVL 트리의 정의에 의해서, 트리에 속하는 모든 노드는 balance factor가 0, 1, 또는 -1 중 하나여야만 한다. 균형이 깨지는 것은 balance factor가 2 이상이거나 -2 이하인 경우라고 할 수 있다. 그런데, 균형이 잘 유지되던, 즉 모든 노드의 balance factor가 -1, 0, 1이던 트리에 하나의 노드를 삽입하거나 제거했다고 해서 balance factor가 갑자기 3 이상이나 -3 이하가 되는 경우는 있을 수 없다. 따라서 균형이 깨지는 경우는 balance factor가 2 이상이거나 -2 이하인 노드가 나타났을 때라고 생각할 수 있다.</p> <p>이러한 경우는 크게 4가지 유형으로 나눌 수 있는데, 각각을 LL, RR, RL, LR이라고 부른다.</p> <ul> <li>LL: <code class="language-plaintext highlighter-rouge">node.left.left</code>가 가장 깊음</li> <li>RR: <code class="language-plaintext highlighter-rouge">node.left.left</code>가 가장 깊음</li> <li>LR: <code class="language-plaintext highlighter-rouge">node.right.left</code>가 가장 깊음</li> <li>RL: <code class="language-plaintext highlighter-rouge">node.left.right</code>가 가장 깊음</li> </ul> <p align="center" style="color:gray"> <img src="/assets/img/BST/bst_6.png" width="80%"> <br> 트리의 균형이 깨지는 4가지 경우. </p> <p>각각을 어떻게 해결해야할지를 생각해보자. 먼저, LL과 RR은 각각 우회전과 좌회전을 적용해주면 바로 해결된다.</p> <p align="center" style="color:gray"> <img src="/assets/img/BST/bst_7.JPG" width="40%"> <br> LL과 RR 유형의 해결 </p> <p>반면 LR과 RL 유형은 바로 해결해줄 수가 없다. 따라서 <strong>억지로 LL, RR 유형으로 바꾸어주어야 한다</strong>. 각각 왼쪽 자식과 오른쪽 자식을 회전시키면 된다.</p> <p align="center" style="color:gray"> <img src="/assets/img/BST/bst_8.jpeg" width="50%"> <br> LR과 RL 유형의 해결 </p> <p>이제 이진 검색 트리와 같은 방식으로 삽입과 삭제를 한 후, 균형이 깨질 때마다 위의 방법으로 균형을 바로잡아주면 된다.</p> <h2 id="검색-1">검색</h2> <p>검색의 경우는 기존 이진검색트리와 다를 것이 없다. 검색만으로는 트리가 바뀌지 않으므로 균형을 다시 맞출 일도 없기 때문이다.</p> <h2 id="삽입-1">삽입</h2> <p>기존 이진검색트리와 같은 방법을 그대로 적용하되, 균형이 깨질 때마다 위에서 설명한 대로 균형을 잡아주면 된다. 이때 재귀를 사용해서 구현한다면 호출된 함수에서 잎 노드에 삽입을 한 후에 호출한 원래 함수로 돌아가며, 쭉 올라가면서 균형을 체크하고 바로잡을 수 있어서 구현이 쉬워진다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>           
        <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_node</span>       
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> 
        <span class="n">node</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>     
        <span class="k">return</span> <span class="n">node</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
        <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">else</span>
        <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    
    <span class="c1"># balancing
</span>    <span class="n">node</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
    <span class="n">balance</span> <span class="o">=</span> <span class="n">balance_factor</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>     <span class="c1"># 왼쪽이 더 깊은데, 왼쪽 자식보다 key값이 작음: LL
</span>        <span class="k">return</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>    <span class="c1"># 왼쪽이 더 깊은데, 왼쪽 자식보다 key값이 큼: LR
</span>        <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">rotate_left</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>     <span class="c1"># 오른쪽이 더 깊은데, 오른쪽 자식보다 key값이 작음: RL
</span>        <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rotate_left</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>    <span class="c1"># 오른쪽이 더 깊은데, 오른쪽 자식보다 key값이 큼: RR
</span>        <span class="k">return</span> <span class="n">rotate_left</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">node</span>
</code></pre></div></div> <h2 id="삭제-1">삭제</h2> <p>마찬가지로 이진검색트리를 그대로 적용하되 균형을 맞추는 코드를 추가해주면 된다. 먼저 “현재 node를 루트로 하는 서브트리에서 key를 가진 노드를 삭제하라”는 의미를 가진 <code class="language-plaintext highlighter-rouge">delete(node, key)</code>에서, 왼쪽 또는 오른쪽 서브트리에서 삭제가 일어날 때마다 균형을 맞춰주는 코드를 넣는다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">delete</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">delete_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
        <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">delete_node</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
    <span class="k">else</span> <span class="c1"># key &gt; node.key
</span>        <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">delete_node</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
    <span class="c1"># balancing
</span>    <span class="n">node</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
    <span class="n">balance</span> <span class="o">=</span> <span class="n">balance_factor</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>     <span class="c1"># 왼쪽이 더 깊은데, 왼쪽 자식보다 key값이 작음: LL
</span>        <span class="k">return</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>    <span class="c1"># 왼쪽이 더 깊은데, 왼쪽 자식보다 key값이 큼: LR
</span>        <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">rotate_left</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>     <span class="c1"># 오른쪽이 더 깊은데, 오른쪽 자식보다 key값이 작음: RL
</span>        <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rotate_left</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>    <span class="c1"># 오른쪽이 더 깊은데, 오른쪽 자식보다 key값이 큼: RR
</span>        <span class="k">return</span> <span class="n">rotate_left</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">node</span>
</code></pre></div></div> <p>그런데, 이것만으로는 충분하지 않다. 위의 코드는 삭제 작업이 끝난 후의 균형을 맞추는 역할을 하는데, 삭제를 하고 삭제된 위치를 대신할 노드를 가져오는 도중에도 균형이 깨질 수 있기 때문이다. 따라서 <code class="language-plaintext highlighter-rouge">delete_node(node)</code> 또한 수정해주어야 한다. 만약 삭제할 노드가 자식이 하나밖에 없다면, 이는 오히려 balance factor를 \(\pm 1\)에서 0으로 만들게 된다. 하지만 삭제할 노드에 자식이 둘이라면 이 노드를 가져오는 과정에서 balance가 또 깨질 수 있다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">delete_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>  <span class="c1"># node를 지우고, 기존 node자리에 오는 새로운 노드를 리턴
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">null</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">null</span>                 <span class="c1"># 기존 node의 자리에는 아무것도 없게 됨
</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>     <span class="c1"># 오른쪽 자식만 존재
</span>        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>    <span class="c1"># 왼쪽 자식만 존재
</span>        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
    <span class="k">else</span>                            <span class="c1"># 두 자식이 모두 존재
</span>       <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">max_left</span><span class="p">)</span> <span class="o">=</span> <span class="n">take_max</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="p">(</span><span class="n">max_left</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">max_left</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>   <span class="c1"># max_left를 node의 원래 위치에 놓기
</span>
        <span class="n">max_left</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_left</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">max_left</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
        <span class="n">balance</span> <span class="o">=</span> <span class="n">balance_factor</span><span class="p">(</span><span class="n">max_left</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span> <span class="o">&gt;=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>    <span class="c1"># LL
</span>            <span class="k">return</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">max_left</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>    <span class="c1"># LR
</span>            <span class="n">max_left</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">rotate_left</span><span class="p">(</span><span class="n">max_left</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">max_left</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>     <span class="c1"># RR
</span>            <span class="n">max_left</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">max_left</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rotate_left</span><span class="p">(</span><span class="n">max_left</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span> <span class="o">&gt;=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>    <span class="c1"># RL
</span>            <span class="k">return</span> <span class="n">rotate_left</span><span class="p">(</span><span class="n">max_left</span><span class="p">)</span>

       <span class="k">return</span> <span class="n">max_left</span>

<span class="n">take_max</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>            <span class="c1"># node의 서브트리의 최대 노드를 찾아서, 부모 노드와 연결 끊고 리턴
</span>    <span class="c1"># 리턴 형식: (새로운 root, 삭제된 노드)
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>     <span class="c1"># 현재 노드가 최대
</span>        <span class="k">return</span> <span class="p">(</span><span class="n">null</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
    <span class="k">else</span>                        <span class="c1"># key 값이 더 큰 노드가 있음
</span>        <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">deleted_node</span><span class="p">)</span> <span class="o">=</span> <span class="n">take_max_left</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">deleted_node</span><span class="p">)</span>
</code></pre></div></div> <h1 id="참고문헌">참고문헌</h1> <p>문병로, <em>쉽게 배우는 자료구조 with 자바</em> (서울:한빛아카데미(주), 2022), pp.338-369 Ibid., pp. 375-400</p> </article><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"alshedivat/al-folio","data-repo-id":"MDEwOlJlcG9zaXRvcnk2MDAyNDM2NQ==","data-category":"Comments","data-category-id":"DIC_kwDOA5PmLc4CTBt6","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,a])=>giscusScript.setAttribute(t,a)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Seojune Lee. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>