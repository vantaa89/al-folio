<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>[Rust] 참조와 포인터 | Seojune Lee</title> <meta name="author" content="Seojune Lee"> <meta name="description" content="Rust에서 포인터처럼 사용할 수 있는 참조자, 원시포인터, Box&lt;T&gt;, Rc&lt;T&gt;, 그리고 RefCell&lt;T&gt; 등에 대해 알아본다"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700%7CRoboto+Slab:100,300,400,500,700%7CMaterial+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https:/vantaa89.github.io//blog/2023/Rust-Pointer/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Seojune </span>Lee</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">[Rust] 참조와 포인터</h1> <p class="post-meta">January 3, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/rust"> <i class="fas fa-hashtag fa-sm"></i> rust</a>   </p> </header> <article class="post-content"> <h1 id="참조자reference">참조자(reference)</h1> <p>C/C++의 참조자와 유사한 개념이다. Rust는 데이터를 가진 변수보다 참조자가 더 오래 존재하지 않도록 체크해줘서 dangling이 일어나지 않도록 방지한다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">calculate_length</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"The length of '{}' is {}."</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">calculate_length</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">s</span><span class="nf">.len</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p>위의 코드에서, 만약 참조자를 사용하지 않았더라면 <code class="language-plaintext highlighter-rouge">calculate_length(s1)</code>을 부르는 순간 소유권이 해당 함수로 넘어가버릴 것이다. 이를 방지해주기 위해서 C와 비슷하게 &amp;를 사용해서 넘겨줄 수 있다.</p> <p>다만, Rust에서의 다른 자료형과 마찬가지로 참조자 또한 기본적으로 불변이다. 따라서 아래와 같이 파라미터를 바꾸는 코드는 에러를 발생시킨다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>

    <span class="nf">change</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">change</span><span class="p">(</span><span class="n">some_string</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">some_string</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">", world"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>이를 해결해주려면</p> <ol> <li>먼저, <code class="language-plaintext highlighter-rouge">s</code>를 <code class="language-plaintext highlighter-rouge">mut</code>로 바꿔야 한다. <div class="language-rust highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
</code></pre></div> </div> </li> <li>참조자 또한 가변 참조자(mutable reference)로 바꿔야 한다. <div class="language-rust highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nf">change</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">);</span>
</code></pre></div> </div> <p>가변 참조자의 경우, 한 가지 제한사항을 가진다.</p> <blockquote> <p>특정한 스코프 내에 특정한 데이터 조각에 대한 가변 참조자를 딱 하나만 만들 수 있다</p> </blockquote> </li> </ol> <p>예를 들어서 다음과 같은 코드는 불가능하다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>

<span class="k">let</span> <span class="n">r1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">;</span>
<span class="k">let</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">;</span>
</code></pre></div></div> <p>이는 데이터 레이스라는 것이 일어나는 것을 컴파일 타임에 방지하기 위한 것이라고 한다. 해결하려면 단지 둘 중 하나를 중괄호로 감싸서 스코프를 만들어주기만 하면 된다.</p> <h1 id="원시-포인터raw-pointers">원시 포인터(Raw Pointers)</h1> <p>C/C++의 포인터와 유사하다. Rust가 해주는 컴파일 타임에서의 dangling 방지를 사용할 수 없다. 따라서 사용이 안전하지 않고, 권장하지 않는듯 하다. Raw pointer의 특징은 다음과 같다.</p> <ul> <li>유효한 메모리 주소를 가리킨다는 것이 보장되지 않는다. NULL이 아닌지 또한 확인하지 않는다. 이는 <code class="language-plaintext highlighter-rouge">Box</code>나 <code class="language-plaintext highlighter-rouge">&amp;</code>와의 가장 큰 차이점이다.</li> <li>메모리 관리를 직접 해주어야 한다. Box와 달리 쓰레기 수집 기능이 없기 때문이다.</li> <li>소유권을 이동시키지 않는다. 따라서 “use-after-free” (free된 후에 참조하는 것)을 방지할 수 없다.</li> <li> <code class="language-plaintext highlighter-rouge">&amp;</code>와 달리 라이프타임 관리 기능이 없다. 즉 danling pointer를 방지할 수 없다.</li> </ul> <p>Rust에서 원시 포인터(raw pointer)라고 불리는 것은 두 가지다.</p> <ul> <li><code class="language-plaintext highlighter-rouge">*const T</code></li> <li> <code class="language-plaintext highlighter-rouge">*mut T</code> 첫번째는 immutable한 변수에 대한 것, 두 번쨰는 mutable한 변수에 대한 것이라고 보면 될 것이다.</li> </ul> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">let</span> <span class="n">raw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">i32</span><span class="p">;</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">let</span> <span class="n">raw_mut</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">y</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">;</span>
</code></pre></div></div> <p>원시 포인터는 위와 같이 간단하게 만들 수 있다. 하지만 이렇게 만든 포인터를 dereference할 때는 가리키는 주소가 안전하지 않을 수 있다는 데에 대한 책임을 져야 한다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">println!</span><span class="p">(</span><span class="s">"raw points at {}"</span><span class="p">,</span> <span class="o">*</span><span class="n">raw</span><span class="p">);</span>             <span class="c1">// compile error</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"raw points at {}"</span><span class="p">,</span> <span class="k">unsafe</span> <span class="p">{</span><span class="o">*</span><span class="n">raw</span><span class="p">});</span>    <span class="c1">// OK</span>
</code></pre></div></div> <h1 id="nonnull"><code class="language-plaintext highlighter-rouge">NonNull</code></h1> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; `*mut T` but non-zero and covariant
</code></pre></div></div> <p>Rust 공식 문서의 설명이다. Null 값을 가지지 않도록 해주며, <code class="language-plaintext highlighter-rouge">Option&lt;NonNull&lt;T&gt;&gt;</code>와 같은 식으로 둘러싸서 필요할 경우에만 <code class="language-plaintext highlighter-rouge">None</code> 값을 가지도록 할 수도 있을 것이다. 공식 documnetation에서는 꼭 필요한 경우가 아니면 그냥 <code class="language-plaintext highlighter-rouge">*mut T</code>를 사용하라고 되어 있다.</p> <h1 id="boxt"><code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code></h1> <p>가장 대표적인 스마트포인터로, 힙에 있는 데이터를 가리키게 되어 있다. 데이터는 힙에 저장하면서, 그것을 가리키는 포인터는 스택에 저장해 두는 것이다. 크기를 컴파일 타임에 알 수 없는 자료형을 저장하고 싶을 때 사용하게 된다.</p> <p>대표적으로, 연결리스트처럼 재귀적인 자료형을 나타낼 때 <code class="language-plaintext highlighter-rouge">Box</code>를 사용하게 된다. 연결리스트의 노드를 생각해보면</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div> <p>와 같은 형태가 될 것이다. 노드에 저장된 수와, 현재 노드가 가리키는 다음 노드를 저장해 두는 것이다. 이런 식의 구현은 자료형의 데이터 크기를 컴파일 타임에 알 수가 없기 떄문에 컴파일이 되지 않는다. 따라서 Box를 사용해서 다음과 같이 구현해야 한다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span>
<span class="p">}</span>
</code></pre></div></div> <p>위와 같은 경우, 실제로 next에 저장되는 것은 Node 그 자체가 아니라 Node를 가리키고 있는 포인터이고, 포인터는 크기가 정해져 있기 때문에 문제 없이 컴파일이 가능하다.</p> <p>Box는 스마트 포인터의 종류라고는 하지만.. Rust가 가지는 소유권이라는 특성상 포인터처럼 자유자재로 쓸 수 있는 것은 아니고, “재귀적인 자료형같은걸 구현할 때 써야 하는 것” 정도의 느낌인 것 같다. 우선 한 객체에 하나의 Box만이 있을 수 있으니 Box를 다루는 것과 Box가 가리키는 객체를 다루는 것에 프로그래머의 입장에서는 체감되는 차이를 잘 모르겠다. 그래서 무언가를 가리킨다는 것이 전혀 연상되지 않는 “Box”라는 이름을 가진게 아닌가 한다. Heap의 데이터를 품고 있는 것이니까..?</p> <h1 id="rct"><code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code></h1> <p>Rc는 Reference Counter를 의마한다. 어떤 객체를 참조하고 있는 포인터가 몇 개인지를 세다가, 카운터가 0이 되면 그 객체를 메모리에서 삭제하고 메모리 관리를 해주는 것이다.</p> <p align="center" style="color:gray"> <img src="https://rinthel.github.io/rust-lang-book-ko/img/trpl15-03.svg" width="80%"><br> 출처: <a href="https://rinthel.github.io/rust-lang-book-ko/ch15-04-rc.html" rel="external nofollow noopener" target="_blank"> Rust 공식 가이드북 </a> </p> <p>위와 같은 데이터 구조를 생각해보자. 이는 Box로는 구현이 불가능하다. a가 가리키고 있는, 5를 저장하고 있는 노드의 소유권이 불명확하기 때문이다. Rust에서 소유권을 가진 것은 하나여야 한다. 이런 경우 <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> 대신 <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>를 사용해서 해결할 수 있다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Node</span><span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span>
<span class="p">}</span>
</code></pre></div></div> <p>편의상 위의 그림에서 5를 가진 노드까지만 나타내고, 그 뒤의 10이나 Nil을 가진 Node는 무시하겠다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node</span><span class="p">{</span><span class="n">value</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">next</span><span class="p">:</span> <span class="nb">None</span><span class="p">});</span>
<span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Node</span><span class="p">{</span><span class="n">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">next</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">))};</span>
<span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Node</span><span class="p">{</span><span class="n">value</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">next</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">))};</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">a</span><span class="py">.value</span><span class="p">);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Output: 5</code></p> <p>Rc가 만들어내는 reference는 읽기만 가능하다. 즉, mut이 아니다. Rust는 mutable reference를 여러 개 만드는 것을 허용하지 않기 떄문이다.</p> <h1 id="refcellt"><code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code></h1> <p><code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>는 <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>의 이런 단점을 해결하기 위해 있는 것으로, 하나의 mutable reference를 만드는 역할을 한다. 위의 코드같은 경우, a가 가리키는 노드에 저장되어 있는 값 5를 수정하는 것은 불가능하다. a, b, c가 모두 immutable reference로 Node를 참조하고 있기 때문이다. 이것을 해결해주려면 Rc안에 RefCell을 살짝 끼워넣어주면 된다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Node</span><span class="p">{</span>
    <span class="k">pub</span> <span class="n">value</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">value</code> 앞에 <code class="language-plaintext highlighter-rouge">pub</code>을 추가한 것은 value를 외부에서 바꾸는 예시를 보여주기 위해서이다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node</span><span class="p">{</span><span class="n">value</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">next</span><span class="p">:</span> <span class="nb">None</span><span class="p">}));</span>
<span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Node</span><span class="p">{</span><span class="n">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">next</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">))};</span>
<span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Node</span><span class="p">{</span><span class="n">value</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">next</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">))};</span>
</code></pre></div></div> <p>이제 <code class="language-plaintext highlighter-rouge">value</code>값을 다음과 같이 바꿀 수 있게 된다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.value</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}, {}"</span><span class="p">,</span> 
    <span class="n">a</span><span class="nf">.borrow</span><span class="p">()</span><span class="py">.value</span><span class="p">,</span> 
    <span class="n">b</span><span class="py">.next</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">()</span><span class="py">.value</span>
<span class="p">);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Output: 10, 10</code></p> <p>여기서 <code class="language-plaintext highlighter-rouge">Rc&lt;RefCell&lt;Node&gt;&gt;</code> 자체는 immutable reference이지만, 그 안에 들어 있는 <code class="language-plaintext highlighter-rouge">RefCell&lt;Node&gt;</code>이 mutable이므로 <code class="language-plaintext highlighter-rouge">value</code>값을 바꾸는 접근을 할 수 있게 된다. 이렇게 <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>는 일반적으로 <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>와 조합해서 많이 사용한다. 이것을 내부 가변성(interior mutability)이라고 한다.</p> <p>위의 코드에서 <code class="language-plaintext highlighter-rouge">RefCell</code>이 가리키는 값에 접근할 때 <code class="language-plaintext highlighter-rouge">borrow()</code>와 <code class="language-plaintext highlighter-rouge">borrow_mut()</code>을 사용한 것을 볼 수 있을 것이다. 이들은 <code class="language-plaintext highlighter-rouge">RefCell</code>이 감싸고 있는 객체에 대한 (immutable) reference와 mutable reference를 만드는 역할을 한다. 이때 Rust의 기본 원칙인, 한 scope안에 동일 객체의 2개 이상 mutable reference가 있을 수 없다는 것에 따라 <code class="language-plaintext highlighter-rouge">borrow_mut()</code>은 한 개만 만들 수 있을 것이다.</p> <h1 id="weakt"><code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code></h1> <p>Reference counter 방식의 스마트 포인터는 기본적으로 순환참조 시의 메모리 누수 문제가 있다. 만약 두 개의 객체가 서로를 참조한다면, 두 객체의 reference counter는 1로, 영원히 메모리에서 사라지지 않게 되기 때문이다. <code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code>는 <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>에서 이를 해결하기 위해 존재하는 타입이다. <code class="language-plaintext highlighter-rouge">Weak</code>라는 이름은 “약한 참조”에서 나온 것으로, 소유권을 가지지 않는 <code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code>의 특징에서 비롯된 것이다.</p> <p><code class="language-plaintext highlighter-rouge">Week&lt;T&gt;</code>는 <code class="language-plaintext highlighter-rouge">weak_count</code>를 1 증가시키는 대신, <code class="language-plaintext highlighter-rouge">strong_count</code>는 증가시키지 않는다. 메모리를 정리하는 것은 <code class="language-plaintext highlighter-rouge">strong_count</code>가 0이 될 때 정리하는 것으로, <code class="language-plaintext highlighter-rouge">week_count</code>와는 관련이 없다. 따라서 두 메모리가 서로를 참조할 때, 하나는 강한 참조(<code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>)로, 하나는 <code class="language-plaintext highlighter-rouge">Week&lt;T&gt;</code>로 참조하는 방식을 사용하면 순환참조를 막아줄 수 있다. 예를 들어서, 양방향 연결리스트(doubly linked list)를 다음과 같이 구현하는 것이 가능하다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span><span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="n">prev</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div> <p>참조하는 값을 정해줄 때는, <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>에서 <code class="language-plaintext highlighter-rouge">clone</code>을 사용한 것 대신에 <code class="language-plaintext highlighter-rouge">Rc::donwgrade()</code>를 사용해주면 약한 참조가 된다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.next</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">));</span>
<span class="n">b</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.prev</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span>
</code></pre></div></div> <h1 id="정리">정리</h1> <center> <style type="text/css">.tg{border-collapse:collapse;border-color:#ccc;border-spacing:0}.tg td{background-color:#fff;border-bottom-width:1px;border-color:#ccc;border-style:solid;border-top-width:1px;border-width:0;color:#333;font-family:Arial,sans-serif;font-size:14px;overflow:hidden;padding:10px 14px;word-break:normal}.tg th{background-color:#f0f0f0;border-bottom-width:1px;border-color:#ccc;border-style:solid;border-top-width:1px;border-width:0;color:#333;font-family:Arial,sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 14px;word-break:normal}.tg .tg-9wq8{border-color:inherit;text-align:center;vertical-align:middle}.tg .tg-l0uw{background-color:#efefef;border-color:inherit;font-family:"Courier New",Courier,monospace!important;text-align:left;vertical-align:middle}.tg .tg-fsme{background-color:#efefef;border-color:inherit;text-align:center;vertical-align:middle}.tg .tg-qoqj{background-color:#f9f9f9;border-color:inherit;font-family:"Courier New",Courier,monospace!important;text-align:left;vertical-align:middle}.tg .tg-kyy7{background-color:#f9f9f9;border-color:inherit;text-align:center;vertical-align:middle}.tg .tg-t7wa{border-color:inherit;font-family:"Courier New",Courier,monospace!important;text-align:left;vertical-align:middle}</style> <table class="tg"> <thead> <tr> <th class="tg-l0uw"></th> <th class="tg-fsme">여러 개 생성 가능</th> <th class="tg-fsme">수정 가능</th> </tr> </thead> <tbody> <tr> <td class="tg-qoqj">Box&lt;T&gt;</td> <td class="tg-kyy7">X</td> <td class="tg-kyy7">X</td> </tr> <tr> <td class="tg-t7wa">Rc&lt;T&gt;</td> <td class="tg-9wq8"><span style="font-weight:400;font-style:normal;text-decoration:none;color:black">O</span></td> <td class="tg-9wq8">X</td> </tr> <tr> <td class="tg-qoqj">RefCell&lt;T&gt;</td> <td class="tg-kyy7"><span style="font-weight:400;font-style:normal;text-decoration:none;color:black">X</span></td> <td class="tg-kyy7"><span style="font-weight:400;font-style:normal;text-decoration:none;color:black">O</span></td> </tr> <tr> <td class="tg-t7wa">Rc&lt;RefCell&lt;T&gt;&gt;</td> <td class="tg-9wq8"><span style="font-weight:400;font-style:normal;text-decoration:none;color:black">O</span></td> <td class="tg-9wq8">O (내부 가변성)</td> </tr> </tbody> </table> </center> <ul> <li> <code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code>: <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>의 순환참조 문제를 해결하기 위해 사용</li> </ul> <h1 id="참고문헌">참고문헌</h1> <p><a href="https://rinthel.github.io/rust-lang-book-ko/ch04-02-references-and-borrowing.html" rel="external nofollow noopener" target="_blank"> Rust 공식 가이드북 (한글 번역) - 참조자와 빌림</a><br> <a href="https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/raw-pointers.html" rel="external nofollow noopener" target="_blank">Rust 공식 가이드북 (영문, 1판) - Raw Pointers </a><br> <a href="https://doc.rust-lang.org/std/ptr/struct.NonNull.html#impl-Pointer-for-NonNull%3CT%3E" rel="external nofollow noopener" target="_blank"> Rust Documentation - <code class="language-plaintext highlighter-rouge">Struct std::ptr::NonNull</code> </a><br> <a href="https://applied-math-coding.medium.com/an-introduction-into-rust-part-12-box-t-rc-t-and-refcell-t-fae061d2d7fb" rel="external nofollow noopener" target="_blank"> Medium - An Introduction into Rust. Part 12: Box&lt;T&gt;, Rc&lt;T&gt; and RefCell&lt;T&gt; </a><br> 쿠지라 히코우즈쿠에. (2023). <em>만들면서 배우는 러스트 프로그래밍</em>. (양현, 역). 파주: 위키북스. (원서출판 2022).</p> </article><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"alshedivat/al-folio","data-repo-id":"MDEwOlJlcG9zaXRvcnk2MDAyNDM2NQ==","data-category":"Comments","data-category-id":"DIC_kwDOA5PmLc4CTBt6","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,a])=>giscusScript.setAttribute(t,a)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Seojune Lee. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>