---
layout: post
title: "이진검색트리와 AVL 트리"
date: 2023-01-14 01:00:00 +0900
description: 이진검색트리와 AVL 트리의 삽입, 검색, 삭제 알고리즘과 그 구현
tags: data-structure
giscus_comments: true
---

# 이진검색트리
AVL 트리를 이해하려면 먼저 이진검색트리(Binary Search Tree)를 알아야 한다. 이진검색트리는 다음의 성질을 만족하는 트리이다. 
* 각 노드는 key와 value값을 하나씩 갖는다. 각 노드의 key값은 모두 서로 다르다.
* 각 노드는 자식이 최대 2개이다.
* 임의의 노드에 대해, 왼쪽 서브트리의 노드들은 모두 key값이 자신보다 작고 오른쪽 서브트리의 노드들은 모두 key값이 자신보다 크다.

key와 value를 대응시키는 표같은 것이 있다고 할 때, 이진 검색 트리를 사용하지 않고 그냥 리스트 형태로 저장해놓는다면 임의의 key값에 대응되는 value를 찾기 위해 $$O(n)$$의 시간이 걸릴 것이다. 반면 BST를 사용하면 이진검색으로 $$\Theta(\lg n)$$만에 검색이 가능하다.

이진검색트리를 시뮬레이션해보는 사이트가 있다. <a href="https:#www.cs.usfca.edu/~galles/visualization/BST.html">이 링크</a>에서 실제 BST의 삽입/삭제/검색을 시뮬레이션해보면 알고리즘을 더욱 잘 이해할 수 있을 것이다.


<p align="center" style="color:gray">
<img src="/assets/img/BST/bst_1.png" width="50%"/>
<br> 이진검색트리의 예시
</p>

## 이진검색트리의 검색, 삽입, 삭제
이진검색트리의 경우 검색과 삭제, 삽입을 모두 재귀적으로 구현할 수 있다.

### 검색
검색의 경우 구현이 직관적이다. 어떤 노드를 루트로 하는 서브트리에서 key값을 가진 노드를 찾는다고 하자. 만약 현재의 노드가 찾는 key값보다 큰 key를 가지고 있다면 찾고있는 노드는 (만약 있다면) 왼쪽 서브트리에 있을 것이다. 반대로 현재 노드가 타겟의 key값보다 작은 key를 가지고 있다면 오른쪽 서브트리에서 검색을 재귀적으로 이어나가면 된다.

```python
search(node, key):
    if (node == null | node.key == key) 
        return node
    else if (key < node.key)
        return search(node.left, key)
    else
        return search(node.right, key)
```

### 삽입
삽입의 경우에도 큰 틀에서는 삽입과 유사하게 구현할 수 있다. 그런데, 검색과는 달리 삽입의 경우에는 트리의 구조가 바뀔 수 있기 때문에 약간의 수정이 필요하다. `insert(node, key, value)`라는 함수가 `node`를 루트로 하는 서브트리에 `(key, value)`라는 노드를 매다는 역할을 하는 함수라고 생각해보자. 단순히 생각해서, `search`의 방식을 그대로 따라하면 다음과 같이 구현이 가능할 것이다. 

```python
insert(node, key, value):
    if (node == null) 
        # 현재 노드의 부모 노드에 `Node(key, value)`를 매단다
    else if (node.key == key)   # key가 이미 존재하면
        node.value = value      # value를 덮어쓴다
    else if (key < node.key)
        return insert(node.left, key, value)
    else
        return insert(node.right, key, value)
```

그런데, `insert`의 입장에서는 `node`의 부모 노드를 알 수 있는 방법이 없다. 이에 대한 해결방법으로, `insert(node, key, value)`가 "삽입 후 해당 서브트리의 새로운 root"를 리턴하게 하는 방법이 있다. `node`를 루트로 하는 서브트리에 새로운 원소를 집어넣었을 때, `node`가 더 이상 그 서브트리의 root가 아니게 될 수도 있으므로 새로 바뀐 root를 함께 리턴해주는 것이다. 이 아이디어는 이후 삭제 알고리즘과 AVL 트리에서도 계속 써먹게 된다.

```python
insert(node, key, value):
    if (node == null)           # 현재 노드가 null이면
        new_node = Node(key, value)
        return new_node         # 새로운 노드를 만들고 그것을 root로 삼는다
    else if (node.key == key)   # key가 이미 존재하면
        node.value = value      # value를 덮어쓴다
        return node
    else if (key < node.key)
        node.left = insert(node.left, key, value)
        return node
    else
        node.right = insert(node.right, key, value)
        return node
```

### 삭제
마찬가지 아이디어로 `delete(node, key)`를 구현한다. 삭제를 할 때는 삭제할 타겟에 세 가지 경우가 있을 것이다.

1. 자식 노드가 없는 경우
    * 타겟 노드를 지워주기만 하면 끝이다.
2. 자식 노드가 하나인 경우
    * 타겟 노드를 지우고, 그 자리는 타겟 노드의 자식이 대신한다.
3. 자식 노드가 둘인 경우
    * 이 경우가 조금 복잡해진다. 
<p align="center" style="color:gray">
<img src="/assets/img/BST/bst_2.png" width="50%"/>
</p>

예를 들어서 위 그림에서 0023을 제거하려는 경우를 생각해보자. 0023을 제거한 후, 이 자리에 다른 노드를 옮겨놓았을 때도 이진검색트리의 성질이 깨지지 않아야 한다. 그러한 노드는 딱 두 개가 있다. **왼쪽 서브트리에서 가장 큰 원소**(여기서는 0022), 그리고 **오른쪽 서브트리에서 가장 작은 원소**(여기서는 0024)이다. 둘 중 하나를 찾아서 원래 노드의 위치에 넣으면 끝이다.
<p align="center" style="color:gray">
<img src="/assets/img/BST/bst_3.png" width="50%"/><br>
0023을 삭제하였을 때. 여기에서는 왼쪽 서브트리의 최대 노드인 0022를 0023의 자리로 가져왔다.
</p>

이를 슈도코드로 구현하면 다음과 같다.
```python
delete(node, key):
    if (key == node.key)
        node = delete_node(node)
        return node
    else if (key < node.key)
        node.left = delete_node(node.left)
        return node
    else # key > node.key
        node.right = delete_node(node.right)
        return node

delete_node(node):  # node를 지우고, 기존 node자리에 오는 새로운 노드를 리턴
    if (node.left == null and node.right == null)
        return null                 # 기존 node의 자리에는 아무것도 없게 됨
    else if (node.left == null)     # 오른쪽 자식만 존재
        return node.right
    else if (node.right == null)    # 왼쪽 자식만 존재
        return node.left
    else                            # 두 자식이 모두 존재
       (node.right, max_left) = take_max(node.left)
        (max_left.left, max_left.right) = (node.left, node.right)   # max_left를 node의 원래 위치에 놓기
       return max_left

take_max(node):            # node의 서브트리의 최대 노드를 찾아서, 부모 노드와 연결 끊고 리턴
    # 리턴 형식: (새로운 root, 삭제된 노드)
    if (node.right == null)     # 현재 노드가 최대
        return (null, node)
    else                        # key 값이 더 큰 노드가 있음
        (node.right, deleted_node) = take_max_left(node.right)
        return (node, deleted_node)
```

# AVL 트리
이진검색트리는 평균적으로는 $$\Theta(\lg n)$$만에 검색이 가능하지만, 다음과 같이 트리의 균형이 무너진 최악의 경우에는 선형의 시간복잡도를 가지게 된다. 이런 경우에는 이진검색트리를 만든 의미가 전혀 없어지게 된다. 

<p align="center" style="color:gray">
<img src="/assets/img/BST/bst_4.png" width="50%"/><br>
35, 23, 22, 10, 5를 차례대로 삽입한 경우. 이런 경우 검색, 삽입, 삭제 모두 시간복잡도가 O(n)이 된다.
</p>

이를 해결하기 위해서 **균형검색트리**를 사용한다. 삽입이나 삭제 시에 트리의 구조를 바꿔서 트리가 계속 균형을 유지하도록 하는 것이다. **AVL 트리**는 Adelson-Velskii와 Landis가 고안한 것으로, 균형검색트리의 대표적인 예시이다. AVL 트리가 되기 위한 조건은 다음과 같다.

* 이진검색트리여야 한다
* 각 노드의 왼쪽 서브트리의 깊이와 오른쪽 서브트리의 깊이가 최대 1만큼 차이나야 한다.

"깊이"라는 특징을 빠르게 계산하기 위해, 각 노드는 이제 `left`, `right` 이외에도 `height`라는 변수를 하나 더 가지게 된다. 이는 바뀔 때마다 새로 업데이트해줘야 한다. 편의상 `null.height == 0`이라고 가정한다.

<a href="https:#www.cs.usfca.edu/~galles/visualization/AVLtree.html">이 사이트</a>에서 AVL 트리의 삽입, 삭제, 검색을 테스트해볼 수 있다.

## 트리의 "좌회전"과 "우회전"
AVL 트리는 균형이 깨진 것을 고치기 위해서 "회전"이라는 것을 사용한다. 이를 기본 도구로 해서 삽입과 삭제 시에 균형을 맞춘다.
<p align="center" style="color:gray">
<img src="/assets/img/BST/bst_5.png" width="70%"/>
<br> 트리의 "좌회전"과 "우회전"
</p>

예시로 좌회전을 슈도코드로 구현해보면 다음과 같다.

```python
rotate_left(node):
    new_root = node.right
    node.right = new_root.left
    new_root.left = node
    node.height = 1 + max(node.left.height, node.right.height)
    new_root.height = 1 + max(new_root.left.height, new_root.right.height)
    return new_root
``` 

## 트리의 균형 맞추기
이제 좌회전과 우회전을 어떤 경우에 적용해서 균형을 맞춰야하는지 생각해봐야 한다. 우선, **balance factor**라는 것을 정의한다.

> **balance factor**는 왼쪽 서브트리의 높이에서 오른쪽 서브트리의 높이를 뺀 것이다.

```python
balance_factor(node):
    return node.left.height - node.right-height
```

AVL 트리의 정의에 의해서, 트리에 속하는 모든 노드는 balance factor가 0, 1, 또는 -1 중 하나여야만 한다. 균형이 깨지는 것은 balance factor가 2 이상이거나 -2 이하인 경우라고 할 수 있다. 그런데, 균형이 잘 유지되던, 즉 모든 노드의 balance factor가 -1, 0, 1이던 트리에 하나의 노드를 삽입하거나 제거했다고 해서 balance factor가 갑자기 3 이상이나 -3 이하가 되는 경우는 있을 수 없다. 따라서 균형이 깨지는 경우는 balance factor가 2 이상이거나 -2 이하인 노드가 나타났을 때라고 생각할 수 있다.

이러한 경우는 크게 4가지 유형으로 나눌 수 있는데, 각각을 LL, RR, RL, LR이라고 부른다.

* LL: `node.left.left`가 가장 깊음
* RR: `node.left.left`가 가장 깊음
* LR: `node.right.left`가 가장 깊음
* RL: `node.left.right`가 가장 깊음

<p align="center" style="color:gray">
<img src="/assets/img/BST/bst_6.png" width="80%"/>
<br> 트리의 균형이 깨지는 4가지 경우.
</p>

각각을 어떻게 해결해야할지를 생각해보자. 먼저, LL과 RR은 각각 우회전과 좌회전을 적용해주면 바로 해결된다.

<p align="center" style="color:gray">
<img src="/assets/img/BST/bst_7.JPG" width="40%"/>
<br> LL과 RR 유형의 해결
</p>

반면 LR과 RL 유형은 바로 해결해줄 수가 없다. 따라서 **억지로 LL, RR 유형으로 바꾸어주어야 한다**. 각각 왼쪽 자식과 오른쪽 자식을 회전시키면 된다.

<p align="center" style="color:gray">
<img src="/assets/img/BST/bst_8.jpeg" width="50%"/>
<br> LR과 RL 유형의 해결
</p>

이제 이진 검색 트리와 같은 방식으로 삽입과 삭제를 한 후, 균형이 깨질 때마다 위의 방법으로 균형을 바로잡아주면 된다.

## 검색
검색의 경우는 기존 이진검색트리와 다를 것이 없다. 검색만으로는 트리가 바뀌지 않으므로 균형을 다시 맞출 일도 없기 때문이다.

## 삽입
기존 이진검색트리와 같은 방법을 그대로 적용하되, 균형이 깨질 때마다 위에서 설명한 대로 균형을 잡아주면 된다. 이때 재귀를 사용해서 구현한다면 호출된 함수에서 잎 노드에 삽입을 한 후에 호출한 원래 함수로 돌아가며, 쭉 올라가면서 균형을 체크하고 바로잡을 수 있어서 구현이 쉬워진다.

```python
insert(node, key, value):
    if (node == null)           
        new_node = Node(key, value)
        return new_node       
    else if (node.key == key) 
        node.value = value     
        return node
    else if (key < node.key)
        node.left = insert(node.left, key, value)
    else
        node.right = insert(node.right, key, value)
    
    # balancing
    node.height = 1 + max(node.left.height, node.right.height)
    balance = balance_factor(node)

    if (balance > 1 && key < node.left.key)     # 왼쪽이 더 깊은데, 왼쪽 자식보다 key값이 작음: LL
        return rotate_right(node);
    if (balance > 1 && key > node.left.key)    # 왼쪽이 더 깊은데, 왼쪽 자식보다 key값이 큼: LR
        node.left = rotate_left(node.left)
        return rotate_right(node)
    if (balance < -1 && key < node.right.key)     # 오른쪽이 더 깊은데, 오른쪽 자식보다 key값이 작음: RL
        node.right = rotate_right(node.right)
        return rotate_left(node)
    if (balance < -1 && key > node.right.key)    # 오른쪽이 더 깊은데, 오른쪽 자식보다 key값이 큼: RR
        return rotate_left(node)
    return node
```

## 삭제
마찬가지로 이진검색트리를 그대로 적용하되 균형을 맞추는 코드를 추가해주면 된다. 먼저 "현재 node를 루트로 하는 서브트리에서 key를 가진 노드를 삭제하라"는 의미를 가진 `delete(node, key)`에서, 왼쪽 또는 오른쪽 서브트리에서 삭제가 일어날 때마다 균형을 맞춰주는 코드를 넣는다.

```python
delete(node, key):
    if (key == node.key)
        node = delete_node(node)
        return node
    else if (key < node.key)
        node.left = delete_node(node.left)
    else # key > node.key
        node.right = delete_node(node.right)
    # balancing
    node.height = 1 + max(node.left.height, node.right.height)
    balance = balance_factor(node)

    if (balance > 1 && key < node.left.key)     # 왼쪽이 더 깊은데, 왼쪽 자식보다 key값이 작음: LL
        return rotate_right(node);
    if (balance > 1 && key > node.left.key)    # 왼쪽이 더 깊은데, 왼쪽 자식보다 key값이 큼: LR
        node.left = rotate_left(node.left)
        return rotate_right(node)
    if (balance < -1 && key < node.right.key)     # 오른쪽이 더 깊은데, 오른쪽 자식보다 key값이 작음: RL
        node.right = rotate_right(node.right)
        return rotate_left(node)
    if (balance < -1 && key > node.right.key)    # 오른쪽이 더 깊은데, 오른쪽 자식보다 key값이 큼: RR
        return rotate_left(node)
    return node
```
 
그런데, 이것만으로는 충분하지 않다. 위의 코드는 삭제 작업이 끝난 후의 균형을 맞추는 역할을 하는데, 삭제를 하고 삭제된 위치를 대신할 노드를 가져오는 도중에도 균형이 깨질 수 있기 때문이다. 따라서 `delete_node(node)` 또한 수정해주어야 한다.
만약 삭제할 노드가 자식이 하나밖에 없다면, 이는 오히려 balance factor를 $$\pm 1$$에서 0으로 만들게 된다. 하지만 삭제할 노드에 자식이 둘이라면 이 노드를 가져오는 과정에서 balance가 또 깨질 수 있다.

```python
delete_node(node):  # node를 지우고, 기존 node자리에 오는 새로운 노드를 리턴
    if (node.left == null and node.right == null)
        return null                 # 기존 node의 자리에는 아무것도 없게 됨
    else if (node.left == null)     # 오른쪽 자식만 존재
        return node.right
    else if (node.right == null)    # 왼쪽 자식만 존재
        return node.left
    else                            # 두 자식이 모두 존재
       (node.right, max_left) = take_max(node.left)
        (max_left.left, max_left.right) = (node.left, node.right)   # max_left를 node의 원래 위치에 놓기

        max_left.height = 1 + max(max_left.left.height, max_left.right.height)
        balance = balance_factor(max_left)

        if (balance > 1 and node.left.left.height >= node.left->right.height)    # LL
            return rotate_right(max_left);
        if (balance > 1 and node.left.left.height < node.left->right.height)    # LR
            max_left.left = rotate_left(max_left.left)
            return rotate_right(max_left)
        if (balance < -1 and node.right.left.height < node.right.right.height)     # RR
            max_left.right = rotate_right(max_left.right)
            return rotate_left(max_left)
        if (balance < -1 and node.right.left.height >= node.right.right.height)    # RL
            return rotate_left(max_left)

       return max_left

take_max(node):            # node의 서브트리의 최대 노드를 찾아서, 부모 노드와 연결 끊고 리턴
    # 리턴 형식: (새로운 root, 삭제된 노드)
    if (node.right == null)     # 현재 노드가 최대
        return (null, node)
    else                        # key 값이 더 큰 노드가 있음
        (node.right, deleted_node) = take_max_left(node.right)
        return (node, deleted_node)
```

# 참고문헌
문병로, _쉽게 배우는 자료구조 with 자바_ (서울:한빛아카데미(주), 2022), pp.338-369
Ibid., pp. 375-400