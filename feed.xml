<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https:/vantaa89.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https:/vantaa89.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2023-01-29T09:34:48+00:00</updated><id>https:/vantaa89.github.io//feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">[강화학습] 2. Learning Policy</title><link href="https:/vantaa89.github.io//blog/2023/RL2/" rel="alternate" type="text/html" title="[강화학습] 2. Learning Policy"/><published>2023-01-28T16:00:00+00:00</published><updated>2023-01-28T16:00:00+00:00</updated><id>https:/vantaa89.github.io//blog/2023/RL2</id><content type="html" xml:base="https:/vantaa89.github.io//blog/2023/RL2/"><![CDATA[<p><a href="/blog/2023/RL/">전의 글</a>에서는 강화학습 환경을 모델링할 수 있는 Markov Decision Process의 개념을 살펴보았고 Optimal Policy를 정의하였다. 또한, Optimal state-value/action function이 만족해야 하는 Bellman Optimality Equation을 살펴보았다. 이번 포스팅에서는 실제로 policy를 iterative한 방법을 통해 계산하는 방법을 알아본다.</p> <h1 id="policyvalue-iteration">Policy/Value Iteration</h1> <h2 id="policy-iteration">Policy Iteration</h2> <p><strong>Policy Iteration</strong>은 크게 <strong>Policy evaluation</strong>과 <strong>Policy improvement</strong>의 과정으로 나뉠 수 있다. 먼저 Policy evaluation은 policy \(\pi\)가 주어질 떄, 이에 대응되는 state-value function \(v^\pi\)를 구하는 것을 말한다. 앞선 포스팅에서, state value-function을 행렬 형태로 나타내면</p> \[v^\pi = R^\pi + \gamma P^\pi v^\pi\] <p>와 같은 방정식을 만족한다는 것을 유도했었다. 물론 inverse를 사용해서 \(v^\pi = (I -\gamma P^\pi )^{-1}R^\pi\) 형태로 만들어줄 수 있다면 좋겠지만 inverse를 직접 계산하는 것은 수치적으로 불안정할 뿐만 아니라 계산이 오래 걸리기 때문에 대신해서 반복법을 사용한다. 방법은 연립방정식을 풀 때 <a href="https://en.wikipedia.org/wiki/Jacobi_method"> Jacobi Method</a>를 사용하는 것과 동일하다.</p> <ul> <li>\(v_1(s)\)를 임의의 값으로 초기화하기</li> <li>\(v_k\)로부터 \(v_{k+1} = R^{\pi}(s) + \gamma \sum_{s'\in\mathcal{S}}\mathcal{P}^\pi(s, s') \cdot v_k(s')\)를 통해 \(v_{k+1}\)를 계산하기</li> </ul> <p>이를 충분히 오래 반복하면, 즉 \(k\to \infty\)로 갈때 \(v_k\)가 만약 수렴한다면 \(\lim_{k\to \infty}v_k = v^\pi\) 는 당연히</p> \[v^\pi = R^\pi + \gamma P^\pi v^\pi\] <p>의 해가 될 것이다. 그렇다면 \(v_k\)가 수렴한다는 사실만 확실하면 되는데, 이는 초기값에 상관없이 수렴한다는 것이 알려져 있다. 즉 위의 방법을 사용하면 주어진 policy로부터 대응되는 state-value function을 얻어낼 수 있다.</p> <p>이제 policy에 대응되는 state-value function을 알았다면 이를 토대로 policy를 수정하는 과정을 거친다. 이것을 <strong>policy improvement</strong>라고 한다. \(l\)번째 policy \(\pi_l\)로부터 개선을 이루어내 \(\pi_{l+1}\)을 계산하는 것이다.</p> <p>Policy improvment를 수행하는 방법 또한 우리의 직관에서 크게 벗어나지 않는다. 우선 전 게시물에서, optimal policy는 단순히 deterministic하다고 가정해도 상관이 없다고 했던 것을 기억할 것이다. 따라서 optimal policy \(\pi^*\)와, 이에 대응되는 action-value function \(q^{\pi^*}\)는</p> \[\pi^*(s) = \text{argmax}_{a\in\mathcal{A}}q^{\pi^*}(s, a)\] <p>를 만족해야 한다. 그런데 현재의 단계에서는 이것이 성립하지 않으므로 policy evaluation에서 썼던 것과 유사한 논리로 iteration을 통해 성립하도록 해주면 되는 것이다.</p> \[\pi_{l+1}(s) = \text{argmax}_{a\in\mathcal{A}}q^{\pi_{l}}(s, a)\] <p>여기에서 \(q^{\pi_l}\)은 \(v^{\pi_l}\)로부터</p> \[q^{\pi_l}(s, a)=R(s, a)+\gamma \sum_{s^{\prime} \in \mathcal{S}} \mathcal{P}\left(s, a, s^{\prime}\right) \cdot v^{\pi_l}(s’)\] <p>로 구해주면 된다.</p> <p>이렇게 policy iteration은 policy evaluation과 improvement를 번갈아가면서 반복해주면 된다.</p> <ul> <li>\(\pi_1\)를 임의의 값으로 설정</li> <li>\(\pi_1\)로부터 <strong>policy evaluation</strong>을 시행해서 \(\pi_1\)에 대응되는 state-value function \(v^{\pi_1}\)을 계산</li> <li>\(v^{\pi_1}\)으로부터 <strong>policy improvement</strong>를 시행해서 \(\pi_2\)를 계산</li> </ul> \[\vdots\] <ul> <li>\(\pi_l\)로부터 <strong>policy evaluation</strong>을 시행해서 \(\pi_l\)에 대응되는 state-value function \(v^{\pi_l}\)을 계산</li> <li>\(v^{\pi_l}\)으로부터 <strong>policy improvement</strong>를 시행해서 \(\pi_{l+1}\)를 계산</li> </ul> <p>이렇게 반복을 거치면,</p> \[\lim_{l\to\infty}\pi_l = \pi^*\] <p>로 수렴함이 증명되어 있다. 이렇게 해서 optimal policy를 구할 수 있었다.</p> <h2 id="value-iteration">Value Iteration</h2> <p><strong>Value iteration</strong> 또한 유사하게 반복법을 사용해서 optimal policy를 계산하지만, policy를 계산하지 않고 value만으로 iteration을 돌린 후에 optimal state-value function \(v^*\)를 얻어 그것으로 \(\pi^*\)를 계산하는 방식이다.</p> <p>Value iteration에서는 Bellman Optimality Equation중, optimal state-value function에 대한 식 하나만을 사용한다.</p> \[v^*(s)=\max _{a \in \mathcal{A}}\left(R(s, a)+\gamma \sum_{s^{\prime} \in \mathcal{S}} \mathcal{P}\left(s, a, s^{\prime}\right) \cdot v^*\left(s^{\prime}\right)\right)\] <p>이것을 점화식</p> \[v_{k+1}(s)=\max _{a \in \mathcal{A}}\left(R(s, a)+\gamma \sum_{s^{\prime} \in \mathcal{S}} \mathcal{P}\left(s, a, s^{\prime}\right) \cdot v_k\left(s^{\prime}\right)\right)\] <p>으로 바꾸어서 위와 같은 방법으로 해를 구해주면 된다. \(v_1(s)\)은 임의로 정해준 후, 위의 점화식을 반복해서 적용해주는 것이다. 이때도 마찬가지로 \(v_k\)가 \(v^*\)로 수렴한다는 것을 증명할 수 있다.</p> <p>Policy/Value Iteration은 Markov decision process \((\mathcal{S, A, P}, R, \gamma)\)에 대한 정보가 모두 알려져 있다면 매우 효과적으로 적용할 수 있다. 다만 \(\mathcal{P}\)와 \(R\)을 model이라고 부르는데, model에 대한 정보를 미리 알고있는 것은 굉장히 강한 조건이다. Model을 모르는 상태에서는 Bellman Optimality Equation을 점화식으로 바꿔 반복하는 위의 방법들을 적용하기가 어렵다. 또, \(\mathcal{S}\)나 \(\mathcal{A}\)의 크기가 크면 적용하기가 어렵다는 단점이 있다.</p> <p>이렇게 Model을 미리 모르는 상태에서 optimal policy를 계산하는 것을 <strong>model-free learning</strong>이라고 한다. model-free learning을 위해서는 다른 알고리즘을 사용해야 한다.</p> <h1 id="model-free-learning">Model-Free Learning</h1> <h2 id="monte-carlo-learning">Monte-Carlo Learning</h2> <p>Model-Free learning의 가장 간단한 방법으로는 <strong>Monte-Carlo Iteration</strong>이 있다. Model이 주어져 있지 않을 때, Policy Iteration에서 문제가 되는 부분은 transition probability \(\mathcal{P}\)를 알 수 없기 떄문에 state-value function을 얻는 policy evaluation이 불가능하다는 점이다. Monte-Carlo iteration에서는 policy evaluation 과정에서 \(v^{\pi_l}\) 대신 \(q^{\pi_l}\)을 사용하며, \(q^{\pi_l}\)의 정확한 값을 얻는 것을 포기하고 대신 그 근사값을 사용한다. 주어진 policy \(\pi_l\)을 따라 액션을 취하면서 state들을 쭉 따라가며 reward를 계산하고, 반복해서 평균을 내는 것이다. 이렇게 해서 \(q^{\pi_l}\)의 근사값을 대략적으로는 구해낼 수가 있다.</p> <p>Policy improvement의 경우 기존과 거의 유사하지만, <strong>exploration</strong>이라는 것을 도입한다. 또한, policy evaluation에서부터 \(v^{\pi_l}\)이 아닌 \(q^{\pi_l}\)을 계산했기 때문에 \(q^{\pi_l}\)를 구하는 계산은 따로 해주지 않아도 되며, 그 덕분에 model이 없어도 계산이 가능하다. Monte Carlo policy improvement에서는 작은 수 \(\epsilon&gt;0\)을 설정하고, \(1-\epsilon\)의 확률로는 기존과 마찬가지로 action-value가 가장 큰 액션(\(\text{argmax}_{a'\in \mathcal{A}} q^{\pi_l}(s, a')\))을 하지만, \(\epsilon\)의 작은 확률로는 그냥 아무 액션이나 해보는 것이다. 전자를 <strong>exploitation</strong>, 후자를 <strong>exploration</strong>이라고 한다. 다양한 경험을 해보기 위해서 모험을 한다는 뜻이다. 식으로 표현하자면 다음과 같다.</p> \[\pi_{\ell+1}(s, a)= \begin{cases}\epsilon /|\mathcal{A}|+1-\epsilon &amp; \text { if } a=\operatorname{argmax}_{a^{\prime} \in \mathcal{A}} q^{\pi_{\ell}}\left(s, a^{\prime}\right) \\ \epsilon /|\mathcal{A}| &amp; \text { otherwise }\end{cases}\] <h2 id="temporal-differnce-learning">Temporal-Differnce Learning</h2> <p>Temporal-Difference Learning은 Monte-Carlo Learning에서 다이나믹 프로그래밍의 요소를 도입해서 state sequence의 끝까지 가보지 않고도 \(q^{\pi_l}\)을 근사하는 방법이다.</p> <h3 id="sarsa">SARSA</h3> <h3 id="q-learning">Q-learning</h3> <h1 id="참고문헌">참고문헌</h1> <p>Lecture 06: Reinforcement Learning, CS Semiar (Machine Learning in Practice) lecture slides, Korea Science Academy of KAIST</p>]]></content><author><name></name></author><category term="deep-learning"/><category term="reinforcement-learning"/><summary type="html"><![CDATA[강화학습의 수학적 기반을 살펴본다]]></summary></entry><entry><title type="html">[강화학습] 1. Markov Decision Process, Optimal Policy</title><link href="https:/vantaa89.github.io//blog/2023/RL/" rel="alternate" type="text/html" title="[강화학습] 1. Markov Decision Process, Optimal Policy"/><published>2023-01-26T16:00:00+00:00</published><updated>2023-01-26T16:00:00+00:00</updated><id>https:/vantaa89.github.io//blog/2023/RL</id><content type="html" xml:base="https:/vantaa89.github.io//blog/2023/RL/"><![CDATA[<h1 id="들어가는-글">들어가는 글</h1> <p>보통 머신러닝을 처음 배울 때 머신러닝의 종류는 세 가지가 있다고 배운다. 지도학습, 비지도학습, 그리고 강화학습이다. 그런데 많은 머신러닝/딥러닝 입문 수업에서 지도학습과 비지도학습은 어느 정도 다루지만 강화학습은 다루지 않는 경우도 많은 것 같다. 이 때문에 강화학습을 접할 기회가 많지 않은 것 같아 이 포스팅에서 강화학습을 한번 살펴보겠다. 먼저 강화학습의 정의를 살펴보자.</p> <blockquote> <p><strong>Reinforcement Learning(강화학습)</strong>: 어떤 환경 안에서 정의된 에이전트가 현재의 상태를 인식하여, 선택 가능한 행동들 중 보상을 최대화하는 행동 혹은 행동 순서를 선택하는 방법 (위키백과)</p> </blockquote> <p>간단한 예제로 한번 살펴보자면, Pong(탁구) 게임을 플레이하는 에이전트를 생각해볼 수 있을 것이다.</p> <p align="center" style="color:gray"> <img src="https://i.guim.co.uk/img/static/sys-images/Technology/Pix/pictures/2008/04/16/Pong460x276.jpg?width=465&amp;quality=85&amp;dpr=1&amp;s=none"/><br/> Pong </p> <p>이 경우 각각은 다음과 같다.</p> <ul> <li>input: 게임의 상태. 픽셀값</li> <li>output: 플레이어가 해야 하는 최적의 행동. 입력이 주어질 때 이것을 학습해야 한다.</li> <li>환경(environment): 게임 프로그램</li> <li>에이전트: 게임을 하는 플레이어. 에이전트가 바를 어떻게 움직이냐에 따라서 환경은 이에 반응해서 점수가 나오게 될 것이다.</li> <li>보상(reward): 점수의 변화량</li> </ul> <p>지도학습의 경우 offline에 input과 output이 주어지는 데 비해서, 비지도학습의 경우에는 output이 주어지지 않고 input의 구조를 파악하는 데에 집중한다. 반면 강화학습은 현재의 상태를 보고 어떤 행동을 해야할지 훈련하는 과정에서, 주변 환경과의 상호작용으로 시간이 지난 후 행동에 따른 보상이나 페널티가 어떻게 나왔는지를 기반으로 학습을 하게 된다. 이를 학습하여 에이전트는 어떤 행동을 해야 보상을 최대화할 수 있는지를 훈련받게 된다.</p> <p>필자는 “정보과학세미나”라는 과목에서 강화학습을 한번 배운 적이 있지만, 당시 시간을 많이 투자하지 못하기도 했고 Tensorflow같은 프레임워크에 익숙하지 않은 채 수업을 들었었기 때문에 내용을 완전히 이해했다고 말하기는 힘든 상태였던 것 같다. 당시 배웠던 내용을 복습하며, 다른 책이나 자료들을 참고해 이 글로 정리해본다.</p> <h1 id="markov-reward-process">Markov Reward Process</h1> <p>먼저, Markov Process라는 개념을 정의하자.</p> <blockquote> <p><strong>Markov Process</strong>(Markov Chain)<br/> A Markov process is a pair \((S, P)\) where</p> <ul> <li>\(\mathcal{S}\): a finite set of states</li> <li>\(\mathcal{P}\): \(S^2 \to [0, 1]\): a state transition probability</li> </ul> </blockquote> <p>즉, 마르코프 과정(또는 체인)은 유한한 상태들의 집합과, 각 상태에서 다음 상태로 갈 확률을 명시해놓은 개념이다.</p> <p align="center" style="color:gray"> <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/Markovkate_01.svg/1920px-Markovkate_01.svg.png" width="40%"/><br/> Markov Process의 예시 </p> <p>위의 경우 첫 번째 행/열을 A, 두 번째 행/열을 E라고 한다면 transition probability \(P\)는 다음과 같이 행렬로 쓸 수 있다.</p> \[\mathcal{P} = \begin{pmatrix} 0.6 &amp; 0.4\\ 0.3 &amp; 0.7 \end{pmatrix}\] <p>Markov Process에서, 다음의 상태로 전이할 확률은 현재의 상태에만 의존하고, 그 전까지 상태들을 지나온 내역(history)에는 의존하지 않는다는 특징이 있다. 이를 식으로 표현하자면 다음과 같다. (\(S_t\): 시간 \(t\)에서의 state)</p> \[\mathbb{P}[S_{t+1}=s'|S_t=s, S_{t-1}, \cdots, S_1] = \mathbb{P}[S_{t+1}=s'|S_t=s] = \mathcal{P}(s, s')\] <p>이 Markov Process에서 <strong>reward function</strong>(보상 함수)과 discount factor를 추가하면 <strong>Markov Reward Process</strong>가 된다.</p> <blockquote> <p><strong>Markov Reward Process</strong><br/> A Markov reward process is a tuple \((\mathcal{S}, \mathcal{P}, R, \gamma)\) where</p> <ul> <li>\((\mathcal{S}, \mathcal{P})\): a Markov process</li> <li>\(R: \mathcal{S}\to \mathbb{R}\): a reward function</li> <li>\(\gamma\): a discount factor</li> </ul> </blockquote> <p>여기에서 \(R\)은 현재의 state에 대한 보상이라고 생각할 수 있다. 어떤 state에 도달하기만 해도, \(R\)이라는 함수가 이에 대한 보상을 부여한다고 생각을 하자. 이것을 토대로 <strong>State-Value Function</strong>이라는 것을 정의한다. 이름에서 알 수 있듯이, 각 state에 대응하는 __가치(value)__를 부여하는 함수이다.</p> <blockquote> <p>Given an MRP \((\mathcal{S}, \mathcal{P}, R, \gamma)\), its <strong>state-value function</strong> \(v: \mathcal{S} \to \mathbb{R}\) is</p> <ul> <li>\(v(s) = \mathbb{E}[\sum_{k=0}^\infty \gamma^k R(N_k(s))]\) <br/> where \(N_k(s)\) is the random variable describing the state after $k$ steps from \(s\).</li> </ul> </blockquote> <p>state-value function은 미래에 받을 보상까지도 모두 기댓값으로 계산해 고려한 것이라고 할 수 있다. 물론 미래에 받을 보상을 현재에 받을 보상과 똑같이 취급하지는 않고, \(k\)번의 스텝 후에 받을 보상은 \(\gamma^k\)만큼 절하해서 고려하는 것이다. \(\gamma\)가 낮을수록 현재의 보상에 더 충실해질 것이고, 높을수록 현재를 조금 희생하더라도 미래에 큰 보상을 받는 방향을 추구하게 될 것이다.</p> <p>그런데 \(v\)는 계산 과정에서 무한급수가 등장하므로 사용이 불편하다. 식을 정리해서 무한급수가 등장하지 않도록 해보자.</p> \[v(s) = \mathbb{E} \left[\sum_{k=0}^\infty \gamma^k R(N_k(s)) \right]\] \[= \mathbb{E}\left[ R(s) + \gamma \sum_{k=0}^\infty \gamma^k R(N_k(N(s))) \right]\] \[= \mathbb{E}\left[R(s) + \gamma \cdot v(N(s)) \right]\] \[= R(s) + \gamma \cdot \sum_{s'\in \mathcal{S}} \left(\mathcal{P}(s, s') v(s')\right)\] <p>이를 행렬로 나타내면 다음과 같다.</p> \[\left(\begin{array}{c}v\left(s_1\right) \\ \vdots \\ v\left(s_n\right)\end{array}\right)=\left(\begin{array}{c}R\left(s_1\right) \\ \vdots \\ R\left(s_n\right)\end{array}\right)+\gamma\left(\begin{array}{ccc}\mathcal{P}\left(s_1, s_1\right) &amp; \ldots &amp; \mathcal{P}\left(s_1, s_n\right) \\ \vdots &amp; \ddots &amp; \vdots \\ \mathcal{P}\left(s_n, s_1\right) &amp; \ldots &amp; \mathcal{P}\left(s_n, s_n\right)\end{array}\right)\left(\begin{array}{c}v\left(s_1\right) \\ \vdots \\ v\left(s_n\right)\end{array}\right)\] <p>즉,</p> \[v= R + \gamma \mathcal{P} v\] <p>이므로</p> \[v = (1-\gamma \mathcal{P})^{-1}R\] <p>이 된다.</p> <h1 id="markov-decision-process">Markov Decision Process</h1> <p>이번에는 <strong>Markov Decision Process</strong>라는 것을 정의한다. 비슷한 용어가 계속 나오지만 헷갈리지 말자. 사실 이걸 정의하기 위해서 앞의 개념들이 나온 것이다.</p> <blockquote> <p><strong>Markov Decision Process</strong><br/> A Markov decision process is a tuple \((\mathcal{S}, \mathcal{A}, \mathcal{P}, R, \gamma)\) where</p> <ul> <li>\(\mathcal{S}\): a finite set of states</li> <li>\(\mathcal{A}\): a finite set of <strong>actions</strong></li> <li>\(\mathcal{P}: \mathcal{S\times A\times S}\to [0, 1]\): a state transition probability</li> <li>\(R: \mathcal{S\times A}\to \mathbb{R}\): a reward function</li> <li>\(\gamma \in [0, 1]\): a discount factor</li> </ul> </blockquote> <p>정의를 보면 action이라는 개념이 새로 나온 것을 제외하면 앞의 Markov reward process와 크게 다르지 않다. 또, MRP에서는 현재의 state가 주어지면 다음 state가 무엇이 될지는 확률적으로 결정될 뿐이었는 데 비해서 MDP에서는 \(P\)가 action에도 의존하는 것이 차이점이다. 즉, <strong>에이전트가 어떤 액션을 가해서 다음 state가 무엇이 될 지 어느 정도 영향을 미칠 수 있는 것이다</strong>. Reward 또한 정의가 바뀌었다. 이제 \(R(s, a)\)는 다음과 같이 정의한다.</p> <blockquote> <p>\(R(s, a)\): 현재 state \(s\)에서 \(a\)를 택했을 때, 다음 state들에서 받을 수 있는 expected reward</p> </blockquote> <p>즉 보상 함수는 현재의 state에 따라서 부여되는 것이 아니라, 현재의 state에서 어떤 action을 취하냐에 따라서도 달라지게 된다는 것이 차이점이다.</p> <p><strong>강화학습의 대상이 되는 문제들은 대부분 environment가 Markov decision process로 나타낼 수 있는 것들이다</strong>.</p> <p>이제 주어진 MDP \((\mathcal{S, A, P}, R, \gamma)\) 에 대해 <strong>Policy</strong>(정책)라는 것을 정의한다.</p> <blockquote> <p><strong>Policy</strong><br/> A policy of an MDP \((\mathcal{S, A, P}, R, \gamma)\) is a probability distribution over actions given states: \(\pi: \mathcal{S \times A} \to [0, 1]\)</p> </blockquote> <p>말이 어려워보이지만 간단히 말해서, 현재의 상태를 보고 에이전트가 어떤 액션을 취할지 결정하는 함수가 바로 policy이다. 이렇게 생각하면 policy(정책)이라는 이름이 잘 지어진 것이라고 느껴진다. 즉, 현재의 state에 따라서 어떤 action이 취해질지가 (확률적으로) 결정되고, 이렇게 결정된 action은 다시 현재의 state와 함께 다음의 state를 확률적으로 결정하는 데 사용된다.</p> <p>MDP \((\mathcal{S, A, P}, R, \gamma)\)와 Policy \(\pi\)가 주어져있다면 state끼리 이동하는 과정은 그냥 Markov Process \((\mathcal{S}, \mathcal{P}^\pi)\) 가 된다. 당연한 것이, 현재의 state를 보고 어떤 action을 취할지가 \(\pi\)에 다 명시되어 있고, 이 action에 따라 다음 state가 뭐가 될 지는 \(\mathcal{P}\)에 나와있기 떄문이다. 이때 현재 state \(s\)에서 다음 state \(s'\)으로 transition할 확률</p> \[\mathcal{P}^\pi(s, s') = \sum_{a\in \mathcal{A}} \pi(s, a) \cdot \mathcal{P} (s, a, s')\] <p>이다. 조금 생각해보면 어렵지 않게 받아들여진다. 또한,</p> \[\mathcal{R}^\pi(s) = \sum_{a\in \mathcal{A}} \pi(s, a) \cdot R(s, a)\] <p>로 정의하면 \((\mathcal{S, P^\pi, R^\pi}, \gamma)\)는 Markov reward process이다.</p> <p>강화학습의 목표는 이 policy를 최적화하는 것이 된다. 즉 현재의 상태(state)를 보고 에이전트가 어떤 액션을 취할지를 최적화하여 보상을 최대화하는 것이 목표이다.</p> <p>한편, 아까 MRP를 정의하면서 각 state에 가치를 부여하는 state-value function이라는 것이 있었던 것을 기억할 것이다. 그런데 이제 MDP에서는 다음의 state는 현재의 state에만 의존해서 결정되는 것이 아니다. action을 어떻게 취할지에 따라서 다음의 state가 달라지고, 또 에이전트가 받게 될 보상이 달라지는 것이다. 따라서 MDP에서는 우리가 취해줄 action 하나하나에 가치를 매겨주는 함수가 필요하다. 이름은 <strong>action-value function</strong>이라고 하면 알맞을 것이다.</p> <blockquote> <p><strong>Action-Value Function</strong><br/> The action-value function \(q^\pi: \mathcal{S\times A}\to \mathbb{R}\) is given by</p> \[q^\pi(s, a) = R(s, a) + \gamma \sum_{s'\in \mathcal{S}}\left(\mathcal{P}(s, a, s') \cdot v^\pi (s'))\right)\] <p>where state-value function \(v^\pi\) is given by</p> \[v^\pi(s) = \mathbb{E}\left[ \sum_{k=0}^\infty \gamma^k R^\pi(N_k^\pi(s)) \right]\] </blockquote> <p>식이 어려워보이지만, 의미를 생각하면 크게 어렵지 않다. policy \(\pi\)가 이미 주어져 있으니, state가 주어지면 어떤 action을 취해야 할지는 확률분포가 바로 결정된다. 이 확률분포를 따라서 예상되는 state transition의 sequence를 확률변수로 나타낸 것이 \(N_k^\pi(s)\) 이다. 이것을 토대로 reward의 기댓값을 구하고, \(\gamma\)로 discount해준 것일 뿐이다.</p> <p>이제 대부분의 강화학습 환경을 모델링할 수 있는 Markov decision process를 알게 되었고, 현재의 상태를 보고 어떤 액션을 취해야 할지를 policy 함수로 결정하면 된다는 것도 알게 되었다. 또, 이러한 policy가 주어졌을 때 각각의 상태와 액션을 어떻게 평가해야 할지 또한 state-value function, action-value function을 정의함으로써 해결하였다. 이제 강화학습의 궁극적 목표인 policy를 결정하는 것만 해내면 된다. 그렇다면 어떤 policy가 좋은 policy일까?</p> <h1 id="optimizing-policy">Optimizing Policy</h1> <p>Optimal policy, 즉 가장 좋은 policy는 다름아닌 위에서 정의한 value function들(state-value function, action-value function)을 최적화하는 policy이다. 그렇다면 state-value function과 action-value function이 최적이라는 것이 무슨 의미인지부터 정의해야 할 것 이다.</p> <blockquote> <p><strong>Optimal State-Value Function</strong><br/> The optimal state-value function \(v^*:\mathcal{S}\to \mathbb{R}\) is defined by</p> <ul> <li>\(v^*(s) = \mathrm{max}\{v^\pi(s) \vert \text{policy }\pi \text{ of the MDP}\}\) for each \(s \in \mathcal{S}\)</li> </ul> </blockquote> <blockquote> <p><strong>Optimal Action-Value Function</strong><br/> The optimal action-value function \(q^*:\mathcal{S\times A}\to \mathbb{R}\) is defined by</p> <ul> <li>\(q^*(s, a) = \mathrm{max}\{q^\pi(s, a) \vert \text{policy }\pi \text{ of the MDP}\}\) for each \(s \in \mathcal{S}, a\in \mathcal{A}\)</li> </ul> </blockquote> <p>즉, optimal state-value function이라 함은 각 state의 state-value값을 최대화하는 policy를 적용하였을 때 가지는 값이라고 할 수 있으며, optimal action-value function 또한 마찬가지로 각 (state, action)의 action-value값을 최대화하는 policy를 적용하였을 때의 값이라고 보면 될 것이다.</p> <p>그런데, optimal state-value function의 정의가 각 state에 대한 것임에 유의하자. 다시 말해, 각 state에 대해서 state-value가 최대가 되는 policy를 선택한 것은 알겠는데, <strong>한 state의 value를 최대화시키는 \(\pi\)가 다른 state의 value도 최대화시키는가</strong>하는 문제가 남아있다. 이것이 만족되지 않으면 optimal policy라는 것은 잘 정의되었다고 말하기 어려울 것이다. 상태(state)가 바뀔 때마다 policy가 바뀌어야 한다면, 그것은 “전략”이라고 말하기가 어려울 것이기 때문이다.</p> <p><strong>따라서, 어떤 policy가 optimal이라고 하기 위해서는 다음이 만족되어야 한다.</strong></p> <blockquote> <p><strong>Optimal Policy</strong><br/> A policy \(\pi^*\) of an MDP \((\mathcal{S, A, P}, R, \gamma)\) is said to be optimal if</p> <ul> <li>\(v^{\pi^*}(s) = v^*(s)\) for all \(s \in \mathcal{S}\)</li> </ul> </blockquote> <p>즉 \(\pi^*\)라는 policy를 선택하면, 모든 state의 state-value값이 최대가 되는 것이다. 이런 \(\pi^*\)가 정말 존재하기는 할까? 놀랍게도 항상 존재한다는 것을 증명할 수 있다.</p> <blockquote> <p><strong>Theorem</strong><br/> For every MDP,</p> <ul> <li>there exists an optimal policy</li> <li>every optimal policy \(\pi^*\) achieves the optimal action-value function <ul> <li>i.e. \(q^{\pi^*}(s, a) = q^*(s, a)\) for all \(s\in \mathcal{S}, a\in \mathcal{A}\)</li> </ul> </li> <li>\(v^*(s) = \text{max}_{a\in \mathcal{A}} q^*(s, a)\).</li> </ul> </blockquote> <p>풀어서 설명하자면, 모든 Markov decision process에는 optimal policy가 존재할 뿐만 아니라 이 policy를 적용하면 모든 action의 action-value function이 최대화된다. 게다가 이게 끝이 아니다.</p> <blockquote> <p><strong>Theorem</strong><br/> There exists a <strong>deterministic</strong> optimal policy for any MDP</p> </blockquote> <p>이러한 optimal policy중에서는 deterministic한 것만 고려해주어도 된다. 즉, 각 state에서 어떤 action을 취할지 결정하는 \(\pi^*\)는 확률분포가 아닌, 결정론적인 형태가 되어도 state-value들을 최대화시킨다는 것이다. 따라서 앞으로는 deterministic한, \(\pi: \mathcal{S}\to \mathcal{A}\)의 함수 형태로서의 policy만을 고려하겠다.</p> <p>이제 만약 optimal action-value function \(q^*\)를 찾았다고 한다면 \(\pi^*\)는 쉽게 구할 수 있다. action-value function이 최대가 되게 하는 action을 선택해주기만 하면 그게 바로 최선의 전략이 되기 때문이다. 식으로 표현해주면 다음과 같다.</p> \[\pi^*(s) = a \Leftrightarrow q^*(s, a) = \text{max}_{a'\in \mathcal{A}} q^*(s, a')\] <h2 id="bellman-optimality-equations">Bellman Optimality Equations</h2> <p>그렇다면 이제 optimal action-value function \(q^*\)를 구하는 과정만이 남았다. 이를 위해 먼저 <strong>Bellman Optimality Equation</strong>이라는 방정식을 한번 살펴보자. Dynamic Programming을 개발하고 Bellman-Ford 알고리즘을 제안한 그 벨만이다.</p> <blockquote> <p><strong>Bellman Optimality Equations</strong></p> \[v^*(s) = \text{max}_{a\in \mathcal{A}} \left( R(s, a) + \gamma \sum_{s'\in \mathcal{S}}\mathcal{P}(s, a, s')\cdot v^*(s') \right)\] \[q^*(s, a)=R(s, a)+\gamma \sum_{s^{\prime} \in \mathcal{S}} \mathcal{P}\left(s, a, s^{\prime}\right) \cdot\left(\max _{a^{\prime} \in \mathcal{A}} q^*\left(s^{\prime}, a^{\prime}\right)\right)\] </blockquote> <p>우선 위의 식은 아래의 식에 \(v^*(s) = \max_{a\in \mathcal{A}} q^*(s, a)\)라는 조건을 적용해주면 바로 나오는 것을 알 수 있다. \(q^*\)에 대한 아래의 식만 살펴보자. 이 또한 \(v^*(s) = \max_{a\in \mathcal{A}} q^*(s, a)\)이므로</p> \[q^*(s, a) = R(s, a) + \gamma \sum_{s'\in \mathcal{S}} \mathcal{P}(s, a, s') \cdot v^*(s)\] <p>과 동치이다. 이렇게 생각하면 어렵지 않게 받아들일 수 있는 식이 된다. (state, action)의 value는 그 reward에다가, 현재의 state에서 transition하는 다음 state의 state-value의 기댓값에 \(\gamma\)의 discount factor를 곱한 것이다.</p> <p>Bellman Optimality Equation은 좌변과 우변에 모두 각각 \(v^*\)와 \(q^*\)가 나온다. 따라서 closed-form으로 해를 정확하게 구하는 것은 불가능하며, iterative method들을 사용하여 해를 구할 수 있다. 이를 구하는 방법으로는 다음이 있다.</p> <ul> <li>Dynamic Programming: policy iteration, value iteration</li> <li>Monte-Carlo Learning</li> <li>Temporal-difference control: SARSA, Q-learning</li> </ul> <p>각각에 대해서는 다음 포스팅에서 계속해서 살펴보겠다.</p> <h1 id="참고문헌">참고문헌</h1> <p>Lecture 06: Reinforcement Learning, CS Semiar (Machine Learning in Practice) lecture slides, Korea Science Academy of KAIST</p>]]></content><author><name></name></author><category term="deep-learning"/><category term="reinforcement-learning"/><summary type="html"><![CDATA[강화학습의 수학적 기반을 살펴본다]]></summary></entry><entry><title type="html">이진검색트리와 AVL 트리</title><link href="https:/vantaa89.github.io//blog/2023/BST/" rel="alternate" type="text/html" title="이진검색트리와 AVL 트리"/><published>2023-01-13T16:00:00+00:00</published><updated>2023-01-13T16:00:00+00:00</updated><id>https:/vantaa89.github.io//blog/2023/BST</id><content type="html" xml:base="https:/vantaa89.github.io//blog/2023/BST/"><![CDATA[<h1 id="이진검색트리">이진검색트리</h1> <p>AVL 트리를 이해하려면 먼저 이진검색트리(Binary Search Tree)를 알아야 한다. 이진검색트리는 다음의 성질을 만족하는 트리이다.</p> <ul> <li>각 노드는 key와 value값을 하나씩 갖는다. 각 노드의 key값은 모두 서로 다르다.</li> <li>각 노드는 자식이 최대 2개이다.</li> <li>임의의 노드에 대해, 왼쪽 서브트리의 노드들은 모두 key값이 자신보다 작고 오른쪽 서브트리의 노드들은 모두 key값이 자신보다 크다.</li> </ul> <p>key와 value를 대응시키는 표같은 것이 있다고 할 때, 이진 검색 트리를 사용하지 않고 그냥 리스트 형태로 저장해놓는다면 임의의 key값에 대응되는 value를 찾기 위해 \(O(n)\)의 시간이 걸릴 것이다. 반면 BST를 사용하면 이진검색으로 \(\Theta(\lg n)\)만에 검색이 가능하다.</p> <p>이진검색트리를 시뮬레이션해보는 사이트가 있다. <a href="https:#www.cs.usfca.edu/~galles/visualization/BST.html">이 링크</a>에서 실제 BST의 삽입/삭제/검색을 시뮬레이션해보면 알고리즘을 더욱 잘 이해할 수 있을 것이다.</p> <p align="center" style="color:gray"> <img src="/assets/img/BST/bst_1.png" width="50%"/> <br/> 이진검색트리의 예시 </p> <h2 id="이진검색트리의-검색-삽입-삭제">이진검색트리의 검색, 삽입, 삭제</h2> <p>이진검색트리의 경우 검색과 삭제, 삽입을 모두 재귀적으로 구현할 수 있다.</p> <h3 id="검색">검색</h3> <p>검색의 경우 구현이 직관적이다. 어떤 노드를 루트로 하는 서브트리에서 key값을 가진 노드를 찾는다고 하자. 만약 현재의 노드가 찾는 key값보다 큰 key를 가지고 있다면 찾고있는 노드는 (만약 있다면) 왼쪽 서브트리에 있을 것이다. 반대로 현재 노드가 타겟의 key값보다 작은 key를 가지고 있다면 오른쪽 서브트리에서 검색을 재귀적으로 이어나가면 된다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">null</span> <span class="o">|</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> 
        <span class="k">return</span> <span class="n">node</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
</code></pre></div></div> <h3 id="삽입">삽입</h3> <p>삽입의 경우에도 큰 틀에서는 삽입과 유사하게 구현할 수 있다. 그런데, 검색과는 달리 삽입의 경우에는 트리의 구조가 바뀔 수 있기 때문에 약간의 수정이 필요하다. <code class="language-plaintext highlighter-rouge">insert(node, key, value)</code>라는 함수가 <code class="language-plaintext highlighter-rouge">node</code>를 루트로 하는 서브트리에 <code class="language-plaintext highlighter-rouge">(key, value)</code>라는 노드를 매다는 역할을 하는 함수라고 생각해보자. 단순히 생각해서, <code class="language-plaintext highlighter-rouge">search</code>의 방식을 그대로 따라하면 다음과 같이 구현이 가능할 것이다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span> 
        <span class="c1"># 현재 노드의 부모 노드에 `Node(key, value)`를 매단다
</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span>   <span class="c1"># key가 이미 존재하면
</span>        <span class="n">node</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>      <span class="c1"># value를 덮어쓴다
</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</code></pre></div></div> <p>그런데, <code class="language-plaintext highlighter-rouge">insert</code>의 입장에서는 <code class="language-plaintext highlighter-rouge">node</code>의 부모 노드를 알 수 있는 방법이 없다. 이에 대한 해결방법으로, <code class="language-plaintext highlighter-rouge">insert(node, key, value)</code>가 “삽입 후 해당 서브트리의 새로운 root”를 리턴하게 하는 방법이 있다. <code class="language-plaintext highlighter-rouge">node</code>를 루트로 하는 서브트리에 새로운 원소를 집어넣었을 때, <code class="language-plaintext highlighter-rouge">node</code>가 더 이상 그 서브트리의 root가 아니게 될 수도 있으므로 새로 바뀐 root를 함께 리턴해주는 것이다. 이 아이디어는 이후 삭제 알고리즘과 AVL 트리에서도 계속 써먹게 된다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>           <span class="c1"># 현재 노드가 null이면
</span>        <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_node</span>         <span class="c1"># 새로운 노드를 만들고 그것을 root로 삼는다
</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span>   <span class="c1"># key가 이미 존재하면
</span>        <span class="n">node</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>      <span class="c1"># value를 덮어쓴다
</span>        <span class="k">return</span> <span class="n">node</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
        <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>
    <span class="k">else</span>
        <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>
</code></pre></div></div> <h3 id="삭제">삭제</h3> <p>마찬가지 아이디어로 <code class="language-plaintext highlighter-rouge">delete(node, key)</code>를 구현한다. 삭제를 할 때는 삭제할 타겟에 세 가지 경우가 있을 것이다.</p> <ol> <li>자식 노드가 없는 경우 <ul> <li>타겟 노드를 지워주기만 하면 끝이다.</li> </ul> </li> <li>자식 노드가 하나인 경우 <ul> <li>타겟 노드를 지우고, 그 자리는 타겟 노드의 자식이 대신한다.</li> </ul> </li> <li>자식 노드가 둘인 경우 <ul> <li>이 경우가 조금 복잡해진다.</li> </ul> </li> </ol> <p align="center" style="color:gray"> <img src="/assets/img/BST/bst_2.png" width="50%"/> </p> <p>예를 들어서 위 그림에서 0023을 제거하려는 경우를 생각해보자. 0023을 제거한 후, 이 자리에 다른 노드를 옮겨놓았을 때도 이진검색트리의 성질이 깨지지 않아야 한다. 그러한 노드는 딱 두 개가 있다. <strong>왼쪽 서브트리에서 가장 큰 원소</strong>(여기서는 0022), 그리고 <strong>오른쪽 서브트리에서 가장 작은 원소</strong>(여기서는 0024)이다. 둘 중 하나를 찾아서 원래 노드의 위치에 넣으면 끝이다.</p> <p align="center" style="color:gray"> <img src="/assets/img/BST/bst_3.png" width="50%"/><br/> 0023을 삭제하였을 때. 여기에서는 왼쪽 서브트리의 최대 노드인 0022를 0023의 자리로 가져왔다. </p> <p>이를 슈도코드로 구현하면 다음과 같다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">delete</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">delete_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
        <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">delete_node</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>
    <span class="k">else</span> <span class="c1"># key &gt; node.key
</span>        <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">delete_node</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>

<span class="n">delete_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>  <span class="c1"># node를 지우고, 기존 node자리에 오는 새로운 노드를 리턴
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">null</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">null</span>                 <span class="c1"># 기존 node의 자리에는 아무것도 없게 됨
</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>     <span class="c1"># 오른쪽 자식만 존재
</span>        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>    <span class="c1"># 왼쪽 자식만 존재
</span>        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
    <span class="k">else</span>                            <span class="c1"># 두 자식이 모두 존재
</span>       <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">max_left</span><span class="p">)</span> <span class="o">=</span> <span class="n">take_max</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="p">(</span><span class="n">max_left</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">max_left</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>   <span class="c1"># max_left를 node의 원래 위치에 놓기
</span>       <span class="k">return</span> <span class="n">max_left</span>

<span class="n">take_max</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>            <span class="c1"># node의 서브트리의 최대 노드를 찾아서, 부모 노드와 연결 끊고 리턴
</span>    <span class="c1"># 리턴 형식: (새로운 root, 삭제된 노드)
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>     <span class="c1"># 현재 노드가 최대
</span>        <span class="k">return</span> <span class="p">(</span><span class="n">null</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
    <span class="k">else</span>                        <span class="c1"># key 값이 더 큰 노드가 있음
</span>        <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">deleted_node</span><span class="p">)</span> <span class="o">=</span> <span class="n">take_max_left</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">deleted_node</span><span class="p">)</span>
</code></pre></div></div> <h1 id="avl-트리">AVL 트리</h1> <p>이진검색트리는 평균적으로는 \(\Theta(\lg n)\)만에 검색이 가능하지만, 다음과 같이 트리의 균형이 무너진 최악의 경우에는 선형의 시간복잡도를 가지게 된다. 이런 경우에는 이진검색트리를 만든 의미가 전혀 없어지게 된다.</p> <p align="center" style="color:gray"> <img src="/assets/img/BST/bst_4.png" width="50%"/><br/> 35, 23, 22, 10, 5를 차례대로 삽입한 경우. 이런 경우 검색, 삽입, 삭제 모두 시간복잡도가 O(n)이 된다. </p> <p>이를 해결하기 위해서 <strong>균형검색트리</strong>를 사용한다. 삽입이나 삭제 시에 트리의 구조를 바꿔서 트리가 계속 균형을 유지하도록 하는 것이다. <strong>AVL 트리</strong>는 Adelson-Velskii와 Landis가 고안한 것으로, 균형검색트리의 대표적인 예시이다. AVL 트리가 되기 위한 조건은 다음과 같다.</p> <ul> <li>이진검색트리여야 한다</li> <li>각 노드의 왼쪽 서브트리의 깊이와 오른쪽 서브트리의 깊이가 최대 1만큼 차이나야 한다.</li> </ul> <p>“깊이”라는 특징을 빠르게 계산하기 위해, 각 노드는 이제 <code class="language-plaintext highlighter-rouge">left</code>, <code class="language-plaintext highlighter-rouge">right</code> 이외에도 <code class="language-plaintext highlighter-rouge">height</code>라는 변수를 하나 더 가지게 된다. 이는 바뀔 때마다 새로 업데이트해줘야 한다. 편의상 <code class="language-plaintext highlighter-rouge">null.height == 0</code>이라고 가정한다.</p> <p><a href="https:#www.cs.usfca.edu/~galles/visualization/AVLtree.html">이 사이트</a>에서 AVL 트리의 삽입, 삭제, 검색을 테스트해볼 수 있다.</p> <h2 id="트리의-좌회전과-우회전">트리의 “좌회전”과 “우회전”</h2> <p>AVL 트리는 균형이 깨진 것을 고치기 위해서 “회전”이라는 것을 사용한다. 이를 기본 도구로 해서 삽입과 삭제 시에 균형을 맞춘다.</p> <p align="center" style="color:gray"> <img src="/assets/img/BST/bst_5.png" width="70%"/> <br/> 트리의 "좌회전"과 "우회전" </p> <p>예시로 좌회전을 슈도코드로 구현해보면 다음과 같다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rotate_left</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">new_root</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>
    <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">new_root</span><span class="p">.</span><span class="n">left</span>
    <span class="n">new_root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">node</span>
    <span class="n">node</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
    <span class="n">new_root</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">new_root</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">new_root</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_root</span>
</code></pre></div></div> <h2 id="트리의-균형-맞추기">트리의 균형 맞추기</h2> <p>이제 좌회전과 우회전을 어떤 경우에 적용해서 균형을 맞춰야하는지 생각해봐야 한다. 우선, <strong>balance factor</strong>라는 것을 정의한다.</p> <blockquote> <p><strong>balance factor</strong>는 왼쪽 서브트리의 높이에서 오른쪽 서브트리의 높이를 뺀 것이다.</p> </blockquote> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">balance_factor</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="o">-</span><span class="n">height</span>
</code></pre></div></div> <p>AVL 트리의 정의에 의해서, 트리에 속하는 모든 노드는 balance factor가 0, 1, 또는 -1 중 하나여야만 한다. 균형이 깨지는 것은 balance factor가 2 이상이거나 -2 이하인 경우라고 할 수 있다. 그런데, 균형이 잘 유지되던, 즉 모든 노드의 balance factor가 -1, 0, 1이던 트리에 하나의 노드를 삽입하거나 제거했다고 해서 balance factor가 갑자기 3 이상이나 -3 이하가 되는 경우는 있을 수 없다. 따라서 균형이 깨지는 경우는 balance factor가 2 이상이거나 -2 이하인 노드가 나타났을 때라고 생각할 수 있다.</p> <p>이러한 경우는 크게 4가지 유형으로 나눌 수 있는데, 각각을 LL, RR, RL, LR이라고 부른다.</p> <ul> <li>LL: <code class="language-plaintext highlighter-rouge">node.left.left</code>가 가장 깊음</li> <li>RR: <code class="language-plaintext highlighter-rouge">node.left.left</code>가 가장 깊음</li> <li>LR: <code class="language-plaintext highlighter-rouge">node.right.left</code>가 가장 깊음</li> <li>RL: <code class="language-plaintext highlighter-rouge">node.left.right</code>가 가장 깊음</li> </ul> <p align="center" style="color:gray"> <img src="/assets/img/BST/bst_6.png" width="80%"/> <br/> 트리의 균형이 깨지는 4가지 경우. </p> <p>각각을 어떻게 해결해야할지를 생각해보자. 먼저, LL과 RR은 각각 우회전과 좌회전을 적용해주면 바로 해결된다.</p> <p align="center" style="color:gray"> <img src="/assets/img/BST/bst_7.JPG" width="40%"/> <br/> LL과 RR 유형의 해결 </p> <p>반면 LR과 RL 유형은 바로 해결해줄 수가 없다. 따라서 <strong>억지로 LL, RR 유형으로 바꾸어주어야 한다</strong>. 각각 왼쪽 자식과 오른쪽 자식을 회전시키면 된다.</p> <p align="center" style="color:gray"> <img src="/assets/img/BST/bst_8.jpeg" width="50%"/> <br/> LR과 RL 유형의 해결 </p> <p>이제 이진 검색 트리와 같은 방식으로 삽입과 삭제를 한 후, 균형이 깨질 때마다 위의 방법으로 균형을 바로잡아주면 된다.</p> <h2 id="검색-1">검색</h2> <p>검색의 경우는 기존 이진검색트리와 다를 것이 없다. 검색만으로는 트리가 바뀌지 않으므로 균형을 다시 맞출 일도 없기 때문이다.</p> <h2 id="삽입-1">삽입</h2> <p>기존 이진검색트리와 같은 방법을 그대로 적용하되, 균형이 깨질 때마다 위에서 설명한 대로 균형을 잡아주면 된다. 이때 재귀를 사용해서 구현한다면 호출된 함수에서 잎 노드에 삽입을 한 후에 호출한 원래 함수로 돌아가며, 쭉 올라가면서 균형을 체크하고 바로잡을 수 있어서 구현이 쉬워진다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>           
        <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_node</span>       
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> 
        <span class="n">node</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>     
        <span class="k">return</span> <span class="n">node</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
        <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">else</span>
        <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    
    <span class="c1"># balancing
</span>    <span class="n">node</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
    <span class="n">balance</span> <span class="o">=</span> <span class="n">balance_factor</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>     <span class="c1"># 왼쪽이 더 깊은데, 왼쪽 자식보다 key값이 작음: LL
</span>        <span class="k">return</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>    <span class="c1"># 왼쪽이 더 깊은데, 왼쪽 자식보다 key값이 큼: LR
</span>        <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">rotate_left</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>     <span class="c1"># 오른쪽이 더 깊은데, 오른쪽 자식보다 key값이 작음: RL
</span>        <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rotate_left</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>    <span class="c1"># 오른쪽이 더 깊은데, 오른쪽 자식보다 key값이 큼: RR
</span>        <span class="k">return</span> <span class="n">rotate_left</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">node</span>
</code></pre></div></div> <h2 id="삭제-1">삭제</h2> <p>마찬가지로 이진검색트리를 그대로 적용하되 균형을 맞추는 코드를 추가해주면 된다. 먼저 “현재 node를 루트로 하는 서브트리에서 key를 가진 노드를 삭제하라”는 의미를 가진 <code class="language-plaintext highlighter-rouge">delete(node, key)</code>에서, 왼쪽 또는 오른쪽 서브트리에서 삭제가 일어날 때마다 균형을 맞춰주는 코드를 넣는다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">delete</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">delete_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
        <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">delete_node</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
    <span class="k">else</span> <span class="c1"># key &gt; node.key
</span>        <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">delete_node</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
    <span class="c1"># balancing
</span>    <span class="n">node</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
    <span class="n">balance</span> <span class="o">=</span> <span class="n">balance_factor</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>     <span class="c1"># 왼쪽이 더 깊은데, 왼쪽 자식보다 key값이 작음: LL
</span>        <span class="k">return</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>    <span class="c1"># 왼쪽이 더 깊은데, 왼쪽 자식보다 key값이 큼: LR
</span>        <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">rotate_left</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>     <span class="c1"># 오른쪽이 더 깊은데, 오른쪽 자식보다 key값이 작음: RL
</span>        <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rotate_left</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>    <span class="c1"># 오른쪽이 더 깊은데, 오른쪽 자식보다 key값이 큼: RR
</span>        <span class="k">return</span> <span class="n">rotate_left</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">node</span>
</code></pre></div></div> <p>그런데, 이것만으로는 충분하지 않다. 위의 코드는 삭제 작업이 끝난 후의 균형을 맞추는 역할을 하는데, 삭제를 하고 삭제된 위치를 대신할 노드를 가져오는 도중에도 균형이 깨질 수 있기 때문이다. 따라서 <code class="language-plaintext highlighter-rouge">delete_node(node)</code> 또한 수정해주어야 한다. 만약 삭제할 노드가 자식이 하나밖에 없다면, 이는 오히려 balance factor를 \(\pm 1\)에서 0으로 만들게 된다. 하지만 삭제할 노드에 자식이 둘이라면 이 노드를 가져오는 과정에서 balance가 또 깨질 수 있다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">delete_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>  <span class="c1"># node를 지우고, 기존 node자리에 오는 새로운 노드를 리턴
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">null</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">null</span>                 <span class="c1"># 기존 node의 자리에는 아무것도 없게 됨
</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>     <span class="c1"># 오른쪽 자식만 존재
</span>        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>    <span class="c1"># 왼쪽 자식만 존재
</span>        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
    <span class="k">else</span>                            <span class="c1"># 두 자식이 모두 존재
</span>       <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">max_left</span><span class="p">)</span> <span class="o">=</span> <span class="n">take_max</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="p">(</span><span class="n">max_left</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">max_left</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>   <span class="c1"># max_left를 node의 원래 위치에 놓기
</span>
        <span class="n">max_left</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_left</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">max_left</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
        <span class="n">balance</span> <span class="o">=</span> <span class="n">balance_factor</span><span class="p">(</span><span class="n">max_left</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span> <span class="o">&gt;=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>    <span class="c1"># LL
</span>            <span class="k">return</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">max_left</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>    <span class="c1"># LR
</span>            <span class="n">max_left</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">rotate_left</span><span class="p">(</span><span class="n">max_left</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">max_left</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>     <span class="c1"># RR
</span>            <span class="n">max_left</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">rotate_right</span><span class="p">(</span><span class="n">max_left</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rotate_left</span><span class="p">(</span><span class="n">max_left</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">height</span> <span class="o">&gt;=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>    <span class="c1"># RL
</span>            <span class="k">return</span> <span class="n">rotate_left</span><span class="p">(</span><span class="n">max_left</span><span class="p">)</span>

       <span class="k">return</span> <span class="n">max_left</span>

<span class="n">take_max</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>            <span class="c1"># node의 서브트리의 최대 노드를 찾아서, 부모 노드와 연결 끊고 리턴
</span>    <span class="c1"># 리턴 형식: (새로운 root, 삭제된 노드)
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>     <span class="c1"># 현재 노드가 최대
</span>        <span class="k">return</span> <span class="p">(</span><span class="n">null</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
    <span class="k">else</span>                        <span class="c1"># key 값이 더 큰 노드가 있음
</span>        <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">deleted_node</span><span class="p">)</span> <span class="o">=</span> <span class="n">take_max_left</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">deleted_node</span><span class="p">)</span>
</code></pre></div></div> <h1 id="참고문헌">참고문헌</h1> <p>문병로, <em>쉽게 배우는 자료구조 with 자바</em> (서울:한빛아카데미(주), 2022), pp.338-369 Ibid., pp. 375-400</p>]]></content><author><name></name></author><category term="data-structure"/><summary type="html"><![CDATA[이진검색트리와 AVL 트리의 삽입, 검색, 삭제 알고리즘과 그 구현]]></summary></entry><entry><title type="html">Modern C++ 문법 정리</title><link href="https:/vantaa89.github.io//blog/2023/Modern-cpp/" rel="alternate" type="text/html" title="Modern C++ 문법 정리"/><published>2023-01-13T16:00:00+00:00</published><updated>2023-01-13T16:00:00+00:00</updated><id>https:/vantaa89.github.io//blog/2023/Modern-cpp</id><content type="html" xml:base="https:/vantaa89.github.io//blog/2023/Modern-cpp/"><![CDATA[<p>C++은 C++98 이후로 굉장히 오랫동안 정체되어 있다가, C++11 업데이트에서 많은 기능이 새로 도입되었다. 이 때문에 C++11 이후의 업데이트인 C++14, C++17, C++20 등을 <strong>모던 C++</strong>이라고 따로 지칭한다. 평소 알고리즘 문제를 풀 떄 정도는 modern C++ 기능들을 알 필요가 별로 없어서 따로 공부할 생각을 하지 않았지만 중요한 몇 개는 알고 있어야 할 것 같아서 정리해본다.</p> <h1 id="auto와-decltype"><code class="language-plaintext highlighter-rouge">auto</code>와 <code class="language-plaintext highlighter-rouge">decltype</code></h1> <h2 id="auto"><code class="language-plaintext highlighter-rouge">auto</code></h2> <p>변수를 선언할 때, 모던 C++에서는 특정 경우 자료형을 따로 지정하지 않아도 알아서 자료형을 추론한다. 단, 선언과 동시에 변수가 초기화되어야 한다. 그러지 않으면 자료형을 알 수가 없기 떄문이다.</p> <pre><code class="language-C++">auto var1 = 100;        // int
auto var2 = 100L;       // long
auto var3 = 100.0;      // double
auto var4 = "string";   // string
auto var5; //ERROR!
</code></pre> <p>특히 iterator와 같은 것들을 귀찮게 적어줄 필요가 없어졌다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vector&lt;int&gt; a;
// 기존
vector&lt;int&gt;::iterator it = a.begin();
// 모던 C++
auto it = a.begin();
</code></pre></div></div> <h2 id="decltype"><code class="language-plaintext highlighter-rouge">decltype</code></h2> <p><code class="language-plaintext highlighter-rouge">decltype</code>은 함수처럼 사용되어서 감싸고 있는 표현의 타입을 알려준다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>     <span class="c1">// int</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>      <span class="c1">// int</span>

<span class="kt">int</span><span class="o">&amp;</span> <span class="n">r_a</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">r_a</span><span class="p">)</span> <span class="n">r_b</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>  <span class="c1">// int&amp;</span>
</code></pre></div></div> <p>값이 아닌 표현이 들어갈 경우에는 조금 더 복잡해지는데, 여기에 대해서는 이후에 추가하겠다.</p> <h1 id="range-based-loop">range-based loop</h1> <p>아마 파이썬에서 영향을 받아온 것 같다. 파이썬에서는</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</code></pre></div></div> <p>처럼 iterable의 원소들을 하나씩 가져와서 매우 쉽게 사용할 수 있다. 기존 C++에서는 이를 위해서는 귀찮게 <code class="language-plaintext highlighter-rouge">iterator</code>를 사용해야 했다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span>
<span class="nf">for</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>하지만 Modern C++에서는 python과 같은 range-based loop를 사용할 수 있다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">e</span><span class="o">:</span> <span class="n">v</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>값을 복사하는 대신 reference를 사용해 가져올 수도 있다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"modern"</span><span class="p">,</span> <span class="s">"C++"</span><span class="p">};</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">e</span><span class="o">:</span> <span class="n">v</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>C++17부터는 pair로 이루어진 list를 아래와 같이 풀어서 쓸 수도 있다. 점점 파이썬과 비슷해지는 것 같다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">),</span> <span class="n">make_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">"modern"</span><span class="p">),</span> <span class="n">make_pair</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="s">"C++"</span><span class="p">)};</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">st</span><span class="p">]</span><span class="o">:</span> <span class="n">v</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">st</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h1 id="람다-함수">람다 함수</h1> <p>파이썬에서처럼 람다 함수(익명 함수)를 사용할 수 있게 되었다. 예를 들어서, 파이썬에서는 다음과 같은 표현이 가능했다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="c1"># 5
</span></code></pre></div></div> <p>특히 이는 내장 함수의 파라미터로 다른 함수가 들어가는 경우에 유용하게 사용할 수 있었다. 예를 들어서 정렬을 할 때, 우리가 정한 함수의 기준으로 정렬을 하고 싶을 수 있다. 그럴 때 우리는 이렇게 써줄 수 있었다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sorted_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">some_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">%</span><span class="mi">12</span><span class="p">)</span>
</code></pre></div></div> <p>이 예시에서 sorted라는 내장함수는 key라는 함수를 받아서, 그 함수가 작은 순서대로 정렬을 하게 된다. 여기에서 굳이 함수를 이름붙여주고 <code class="language-plaintext highlighter-rouge">def</code>를 사용해 정의하기보다 저렇게 inline으로 써주는 것이 훨씬 간단하다. 마찬가지로 C++에서도 람다 함수를 사용할 수 있다. 다만 문법은 조금 다르다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">};</span>
<span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>    <span class="c1">// 7</span>
</code></pre></div></div> <p>각 부분의 의미를 살펴보면 이렇다.</p> <ul> <li>[]: 캡처. 안에 들어가는 이름의 외부변수를 복사하거나 참조해온다.</li> <li>(): 매개변수</li> <li>{}: 함수의 동작</li> </ul> <p>또한, <code class="language-plaintext highlighter-rouge">f</code>의 타입이 auto로 자동결정되는 것을 알 수 있는데 사실 <code class="language-plaintext highlighter-rouge">f</code>의 타입은 함수 포인터로, <code class="language-plaintext highlighter-rouge">void (*f)(int a, int b)</code>와 같은 형식이 된다. 이를 굳이 적어주기는 번거로우니 <code class="language-plaintext highlighter-rouge">auto</code>를 사용하면 된다.</p> <p>매개변수와 함수의 동작은 기존 함수와 다를 것이 없다. C++의 람다 함수에서 처음 나오는 개념은 캡처라는 것이다. 이는 함수 외부에서 정의된 상수나 변수를 람다 함수 안에서 사용해주기 위해서 적어주는 것이다. 예를 들어서 다음과 같이 사용할 수 있다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">val1</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">val2</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val1</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">val2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span>  <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">val1</code>과 <code class="language-plaintext highlighter-rouge">val2</code>를 복사하지 않고 reference를 통해 가져오는 것도 가능하다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">val1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val2</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val1</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">val2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span>  <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>만약 모든 변수를 가져오고 싶다면 다음과 같이 하면 된다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>                <span class="c1">// 모든 변수를 복사해서 가져온다</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val1</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">val2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span>  <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>                <span class="c1">// 모든 변수를 reference로 가져온다</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val1</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">val2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span>  <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h1 id="스마트-포인터">스마트 포인터</h1> <p>C++11에서는 <code class="language-plaintext highlighter-rouge">std::auto_ptr</code>이 처음 도입되었지만, 이는 더 이상 사용되지 않는다. 대신 <code class="language-plaintext highlighter-rouge">std::unique_ptr</code>, <code class="language-plaintext highlighter-rouge">std::shared_ptr</code>, <code class="language-plaintext highlighter-rouge">std::weak_ptr</code>가 도입되었다. 이는 러스트에서 사용하는 소유권의 개념과도 매우 비슷하다.</p> <h2 id="stdunique_ptr"><code class="language-plaintext highlighter-rouge">std::unique_ptr</code></h2> <p><code class="language-plaintext highlighter-rouge">unique_ptr</code>은 기존 포인터와 달리, 가리키는 대상을 자신이 “소유”하는 것으로 볼 수 있다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="c1">// 또는</span>
<span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="k">new</span> <span class="kt">int</span> <span class="p">{</span><span class="mi">5</span><span class="p">}};</span>

<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 5</span>
</code></pre></div></div> <p>위와 같이 정의해주면 <code class="language-plaintext highlighter-rouge">a</code>는 이름에 맞게 5를 가리키는 “유일한 포인터”가 된다. 즉 <code class="language-plaintext highlighter-rouge">a</code>를 통하지 않고는 5에 접근할 수가 없다. 즉 아래와 같이 <code class="language-plaintext highlighter-rouge">a</code>를 복사하는 것이 불가능하다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>     <span class="c1">// compile error</span>
</code></pre></div></div> <p>왜냐하면 <code class="language-plaintext highlighter-rouge">a</code>만이 5를 가리키는 유일한 포인터여야 하기 때문이다. 대신 소유권을 이전할 수는 있는데, 그러면 <code class="language-plaintext highlighter-rouge">a</code>로는 더 이상 5에 접근할 수 없게 된다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</code></pre></div></div> <h2 id="stdshared_ptr"><code class="language-plaintext highlighter-rouge">std::shared_ptr</code></h2> <p>Shared pointer의 경우 reference count 방식으로 메모리를 관리한다. 이름에서 알 수 있듯이, <code class="language-plaintext highlighter-rouge">unique_ptr</code>와는 달리 여러 포인터가 한 객체를 가리키는 것이 가능하다. 여기에서 reference count라는 말은, 특정 객체를 가리키는 포인터의 개수를 세고 있다가 0이 되는 순간 메모리를 해제해준다는 뜻이다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>        <span class="c1">// 5 5</span>
</code></pre></div></div> <p>한편, reference counter 방식의 포인터는 <a href="/blog/2023/Rust-Pointer/">이 링크</a>에서 설명해두었듯이 두 포인터가 서로를 참조하는 경우 영원히 메모리에서 삭제되지 않게 된다. 이를 방지하기 위해서 <code class="language-plaintext highlighter-rouge">std::weak_ptr</code>를 함께 사용해준다.</p>]]></content><author><name></name></author><category term="data-structure"/><summary type="html"><![CDATA[C++11 이상에서 새로 도입된 대표적인 modern c++ 문법]]></summary></entry><entry><title type="html">[Rust] 참조와 포인터</title><link href="https:/vantaa89.github.io//blog/2023/Rust-Pointer/" rel="alternate" type="text/html" title="[Rust] 참조와 포인터"/><published>2023-01-03T16:00:00+00:00</published><updated>2023-01-03T16:00:00+00:00</updated><id>https:/vantaa89.github.io//blog/2023/Rust-Pointer</id><content type="html" xml:base="https:/vantaa89.github.io//blog/2023/Rust-Pointer/"><![CDATA[<h1 id="참조자reference">참조자(reference)</h1> <p>C/C++의 참조자와 유사한 개념이다. Rust는 데이터를 가진 변수보다 참조자가 더 오래 존재하지 않도록 체크해줘서 dangling이 일어나지 않도록 방지한다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">calculate_length</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"The length of '{}' is {}."</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">calculate_length</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">s</span><span class="nf">.len</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p>위의 코드에서, 만약 참조자를 사용하지 않았더라면 <code class="language-plaintext highlighter-rouge">calculate_length(s1)</code>을 부르는 순간 소유권이 해당 함수로 넘어가버릴 것이다. 이를 방지해주기 위해서 C와 비슷하게 &amp;를 사용해서 넘겨줄 수 있다.</p> <p>다만, Rust에서의 다른 자료형과 마찬가지로 참조자 또한 기본적으로 불변이다. 따라서 아래와 같이 파라미터를 바꾸는 코드는 에러를 발생시킨다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>

    <span class="nf">change</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">change</span><span class="p">(</span><span class="n">some_string</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">some_string</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">", world"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>이를 해결해주려면</p> <ol> <li>먼저, <code class="language-plaintext highlighter-rouge">s</code>를 <code class="language-plaintext highlighter-rouge">mut</code>로 바꿔야 한다. <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
</code></pre></div> </div> </li> <li>참조자 또한 가변 참조자(mutable reference)로 바꿔야 한다. <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">change</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">);</span>
</code></pre></div> </div> <p>가변 참조자의 경우, 한 가지 제한사항을 가진다.</p> <blockquote> <p>특정한 스코프 내에 특정한 데이터 조각에 대한 가변 참조자를 딱 하나만 만들 수 있다</p> </blockquote> </li> </ol> <p>예를 들어서 다음과 같은 코드는 불가능하다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>

<span class="k">let</span> <span class="n">r1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">;</span>
<span class="k">let</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">;</span>
</code></pre></div></div> <p>이는 데이터 레이스라는 것이 일어나는 것을 컴파일 타임에 방지하기 위한 것이라고 한다. 해결하려면 단지 둘 중 하나를 중괄호로 감싸서 스코프를 만들어주기만 하면 된다.</p> <h1 id="원시-포인터raw-pointers">원시 포인터(Raw Pointers)</h1> <p>C/C++의 포인터와 유사하다. Rust가 해주는 컴파일 타임에서의 dangling 방지를 사용할 수 없다. 따라서 사용이 안전하지 않고, 권장하지 않는듯 하다. Raw pointer의 특징은 다음과 같다.</p> <ul> <li>유효한 메모리 주소를 가리킨다는 것이 보장되지 않는다. NULL이 아닌지 또한 확인하지 않는다. 이는 <code class="language-plaintext highlighter-rouge">Box</code>나 <code class="language-plaintext highlighter-rouge">&amp;</code>와의 가장 큰 차이점이다.</li> <li>메모리 관리를 직접 해주어야 한다. Box와 달리 쓰레기 수집 기능이 없기 때문이다.</li> <li>소유권을 이동시키지 않는다. 따라서 “use-after-free” (free된 후에 참조하는 것)을 방지할 수 없다.</li> <li><code class="language-plaintext highlighter-rouge">&amp;</code>와 달리 라이프타임 관리 기능이 없다. 즉 danling pointer를 방지할 수 없다.</li> </ul> <p>Rust에서 원시 포인터(raw pointer)라고 불리는 것은 두 가지다.</p> <ul> <li><code class="language-plaintext highlighter-rouge">*const T</code></li> <li><code class="language-plaintext highlighter-rouge">*mut T</code> 첫번째는 immutable한 변수에 대한 것, 두 번쨰는 mutable한 변수에 대한 것이라고 보면 될 것이다.</li> </ul> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">let</span> <span class="n">raw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">i32</span><span class="p">;</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">let</span> <span class="n">raw_mut</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">y</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">;</span>
</code></pre></div></div> <p>원시 포인터는 위와 같이 간단하게 만들 수 있다. 하지만 이렇게 만든 포인터를 dereference할 때는 가리키는 주소가 안전하지 않을 수 있다는 데에 대한 책임을 져야 한다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">println!</span><span class="p">(</span><span class="s">"raw points at {}"</span><span class="p">,</span> <span class="o">*</span><span class="n">raw</span><span class="p">);</span>             <span class="c1">// compile error</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"raw points at {}"</span><span class="p">,</span> <span class="k">unsafe</span> <span class="p">{</span><span class="o">*</span><span class="n">raw</span><span class="p">});</span>    <span class="c1">// OK</span>
</code></pre></div></div> <h1 id="nonnull"><code class="language-plaintext highlighter-rouge">NonNull</code></h1> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; `*mut T` but non-zero and covariant
</code></pre></div></div> <p>Rust 공식 문서의 설명이다. Null 값을 가지지 않도록 해주며, <code class="language-plaintext highlighter-rouge">Option&lt;NonNull&lt;T&gt;&gt;</code>와 같은 식으로 둘러싸서 필요할 경우에만 <code class="language-plaintext highlighter-rouge">None</code> 값을 가지도록 할 수도 있을 것이다. 공식 documnetation에서는 꼭 필요한 경우가 아니면 그냥 <code class="language-plaintext highlighter-rouge">*mut T</code>를 사용하라고 되어 있다.</p> <h1 id="boxt"><code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code></h1> <p>가장 대표적인 스마트포인터로, 힙에 있는 데이터를 가리키게 되어 있다. 데이터는 힙에 저장하면서, 그것을 가리키는 포인터는 스택에 저장해 두는 것이다. 크기를 컴파일 타임에 알 수 없는 자료형을 저장하고 싶을 때 사용하게 된다.</p> <p>대표적으로, 연결리스트처럼 재귀적인 자료형을 나타낼 때 <code class="language-plaintext highlighter-rouge">Box</code>를 사용하게 된다. 연결리스트의 노드를 생각해보면</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div> <p>와 같은 형태가 될 것이다. 노드에 저장된 수와, 현재 노드가 가리키는 다음 노드를 저장해 두는 것이다. 이런 식의 구현은 자료형의 데이터 크기를 컴파일 타임에 알 수가 없기 떄문에 컴파일이 되지 않는다. 따라서 Box를 사용해서 다음과 같이 구현해야 한다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span>
<span class="p">}</span>
</code></pre></div></div> <p>위와 같은 경우, 실제로 next에 저장되는 것은 Node 그 자체가 아니라 Node를 가리키고 있는 포인터이고, 포인터는 크기가 정해져 있기 때문에 문제 없이 컴파일이 가능하다.</p> <p>Box는 스마트 포인터의 종류라고는 하지만.. Rust가 가지는 소유권이라는 특성상 포인터처럼 자유자재로 쓸 수 있는 것은 아니고, “재귀적인 자료형같은걸 구현할 때 써야 하는 것” 정도의 느낌인 것 같다. 우선 한 객체에 하나의 Box만이 있을 수 있으니 Box를 다루는 것과 Box가 가리키는 객체를 다루는 것에 프로그래머의 입장에서는 체감되는 차이를 잘 모르겠다. 그래서 무언가를 가리킨다는 것이 전혀 연상되지 않는 “Box”라는 이름을 가진게 아닌가 한다. Heap의 데이터를 품고 있는 것이니까..?</p> <h1 id="rct"><code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code></h1> <p>Rc는 Reference Counter를 의마한다. 어떤 객체를 참조하고 있는 포인터가 몇 개인지를 세다가, 카운터가 0이 되면 그 객체를 메모리에서 삭제하고 메모리 관리를 해주는 것이다.</p> <p align="center" style="color:gray"> <img src="https://rinthel.github.io/rust-lang-book-ko/img/trpl15-03.svg" width="80%"/><br/> 출처: <a href="https://rinthel.github.io/rust-lang-book-ko/ch15-04-rc.html"> Rust 공식 가이드북 </a> </p> <p>위와 같은 데이터 구조를 생각해보자. 이는 Box로는 구현이 불가능하다. a가 가리키고 있는, 5를 저장하고 있는 노드의 소유권이 불명확하기 때문이다. Rust에서 소유권을 가진 것은 하나여야 한다. 이런 경우 <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> 대신 <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>를 사용해서 해결할 수 있다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Node</span><span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span>
<span class="p">}</span>
</code></pre></div></div> <p>편의상 위의 그림에서 5를 가진 노드까지만 나타내고, 그 뒤의 10이나 Nil을 가진 Node는 무시하겠다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node</span><span class="p">{</span><span class="n">value</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">next</span><span class="p">:</span> <span class="nb">None</span><span class="p">});</span>
<span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Node</span><span class="p">{</span><span class="n">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">next</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">))};</span>
<span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Node</span><span class="p">{</span><span class="n">value</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">next</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">))};</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">a</span><span class="py">.value</span><span class="p">);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Output: 5</code></p> <p>Rc가 만들어내는 reference는 읽기만 가능하다. 즉, mut이 아니다. Rust는 mutable reference를 여러 개 만드는 것을 허용하지 않기 떄문이다.</p> <h1 id="refcellt"><code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code></h1> <p><code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>는 <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>의 이런 단점을 해결하기 위해 있는 것으로, 하나의 mutable reference를 만드는 역할을 한다. 위의 코드같은 경우, a가 가리키는 노드에 저장되어 있는 값 5를 수정하는 것은 불가능하다. a, b, c가 모두 immutable reference로 Node를 참조하고 있기 때문이다. 이것을 해결해주려면 Rc안에 RefCell을 살짝 끼워넣어주면 된다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Node</span><span class="p">{</span>
    <span class="k">pub</span> <span class="n">value</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">value</code> 앞에 <code class="language-plaintext highlighter-rouge">pub</code>을 추가한 것은 value를 외부에서 바꾸는 예시를 보여주기 위해서이다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node</span><span class="p">{</span><span class="n">value</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">next</span><span class="p">:</span> <span class="nb">None</span><span class="p">}));</span>
<span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Node</span><span class="p">{</span><span class="n">value</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">next</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">))};</span>
<span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Node</span><span class="p">{</span><span class="n">value</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">next</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">))};</span>
</code></pre></div></div> <p>이제 <code class="language-plaintext highlighter-rouge">value</code>값을 다음과 같이 바꿀 수 있게 된다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.value</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}, {}"</span><span class="p">,</span> 
    <span class="n">a</span><span class="nf">.borrow</span><span class="p">()</span><span class="py">.value</span><span class="p">,</span> 
    <span class="n">b</span><span class="py">.next</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.borrow</span><span class="p">()</span><span class="py">.value</span>
<span class="p">);</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Output: 10, 10</code></p> <p>여기서 <code class="language-plaintext highlighter-rouge">Rc&lt;RefCell&lt;Node&gt;&gt;</code> 자체는 immutable reference이지만, 그 안에 들어 있는 <code class="language-plaintext highlighter-rouge">RefCell&lt;Node&gt;</code>이 mutable이므로 <code class="language-plaintext highlighter-rouge">value</code>값을 바꾸는 접근을 할 수 있게 된다. 이렇게 <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>는 일반적으로 <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>와 조합해서 많이 사용한다. 이것을 내부 가변성(interior mutability)이라고 한다.</p> <p>위의 코드에서 <code class="language-plaintext highlighter-rouge">RefCell</code>이 가리키는 값에 접근할 때 <code class="language-plaintext highlighter-rouge">borrow()</code>와 <code class="language-plaintext highlighter-rouge">borrow_mut()</code>을 사용한 것을 볼 수 있을 것이다. 이들은 <code class="language-plaintext highlighter-rouge">RefCell</code>이 감싸고 있는 객체에 대한 (immutable) reference와 mutable reference를 만드는 역할을 한다. 이때 Rust의 기본 원칙인, 한 scope안에 동일 객체의 2개 이상 mutable reference가 있을 수 없다는 것에 따라 <code class="language-plaintext highlighter-rouge">borrow_mut()</code>은 한 개만 만들 수 있을 것이다.</p> <h1 id="weakt"><code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code></h1> <p>Reference counter 방식의 스마트 포인터는 기본적으로 순환참조 시의 메모리 누수 문제가 있다. 만약 두 개의 객체가 서로를 참조한다면, 두 객체의 reference counter는 1로, 영원히 메모리에서 사라지지 않게 되기 때문이다. <code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code>는 <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>에서 이를 해결하기 위해 존재하는 타입이다. <code class="language-plaintext highlighter-rouge">Weak</code>라는 이름은 “약한 참조”에서 나온 것으로, 소유권을 가지지 않는 <code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code>의 특징에서 비롯된 것이다.</p> <p><code class="language-plaintext highlighter-rouge">Week&lt;T&gt;</code>는 <code class="language-plaintext highlighter-rouge">weak_count</code>를 1 증가시키는 대신, <code class="language-plaintext highlighter-rouge">strong_count</code>는 증가시키지 않는다. 메모리를 정리하는 것은 <code class="language-plaintext highlighter-rouge">strong_count</code>가 0이 될 때 정리하는 것으로, <code class="language-plaintext highlighter-rouge">week_count</code>와는 관련이 없다. 따라서 두 메모리가 서로를 참조할 때, 하나는 강한 참조(<code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>)로, 하나는 <code class="language-plaintext highlighter-rouge">Week&lt;T&gt;</code>로 참조하는 방식을 사용하면 순환참조를 막아줄 수 있다. 예를 들어서, 양방향 연결리스트(doubly linked list)를 다음과 같이 구현하는 것이 가능하다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span><span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">isize</span><span class="p">,</span>
    <span class="n">prev</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div> <p>참조하는 값을 정해줄 때는, <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>에서 <code class="language-plaintext highlighter-rouge">clone</code>을 사용한 것 대신에 <code class="language-plaintext highlighter-rouge">Rc::donwgrade()</code>를 사용해주면 약한 참조가 된다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.next</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">));</span>
<span class="n">b</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="py">.prev</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Rc</span><span class="p">::</span><span class="nf">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span>
</code></pre></div></div> <h1 id="정리">정리</h1> <center> <style type="text/css">.tg{border-collapse:collapse;border-color:#ccc;border-spacing:0}.tg td{background-color:#fff;border-bottom-width:1px;border-color:#ccc;border-style:solid;border-top-width:1px;border-width:0;color:#333;font-family:Arial,sans-serif;font-size:14px;overflow:hidden;padding:10px 14px;word-break:normal}.tg th{background-color:#f0f0f0;border-bottom-width:1px;border-color:#ccc;border-style:solid;border-top-width:1px;border-width:0;color:#333;font-family:Arial,sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 14px;word-break:normal}.tg .tg-9wq8{border-color:inherit;text-align:center;vertical-align:middle}.tg .tg-l0uw{background-color:#efefef;border-color:inherit;font-family:"Courier New",Courier,monospace!important;text-align:left;vertical-align:middle}.tg .tg-fsme{background-color:#efefef;border-color:inherit;text-align:center;vertical-align:middle}.tg .tg-qoqj{background-color:#f9f9f9;border-color:inherit;font-family:"Courier New",Courier,monospace!important;text-align:left;vertical-align:middle}.tg .tg-kyy7{background-color:#f9f9f9;border-color:inherit;text-align:center;vertical-align:middle}.tg .tg-t7wa{border-color:inherit;font-family:"Courier New",Courier,monospace!important;text-align:left;vertical-align:middle}</style> <table class="tg"> <thead> <tr> <th class="tg-l0uw"></th> <th class="tg-fsme">여러 개 생성 가능</th> <th class="tg-fsme">수정 가능</th> </tr> </thead> <tbody> <tr> <td class="tg-qoqj">Box&lt;T&gt;</td> <td class="tg-kyy7">X</td> <td class="tg-kyy7">X</td> </tr> <tr> <td class="tg-t7wa">Rc&lt;T&gt;</td> <td class="tg-9wq8"><span style="font-weight:400;font-style:normal;text-decoration:none;color:black">O</span></td> <td class="tg-9wq8">X</td> </tr> <tr> <td class="tg-qoqj">RefCell&lt;T&gt;</td> <td class="tg-kyy7"><span style="font-weight:400;font-style:normal;text-decoration:none;color:black">X</span></td> <td class="tg-kyy7"><span style="font-weight:400;font-style:normal;text-decoration:none;color:black">O</span></td> </tr> <tr> <td class="tg-t7wa">Rc&lt;RefCell&lt;T&gt;&gt;</td> <td class="tg-9wq8"><span style="font-weight:400;font-style:normal;text-decoration:none;color:black">O</span></td> <td class="tg-9wq8">O (내부 가변성)</td> </tr> </tbody> </table> </center> <ul> <li><code class="language-plaintext highlighter-rouge">Weak&lt;T&gt;</code>: <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code>의 순환참조 문제를 해결하기 위해 사용</li> </ul> <h1 id="참고문헌">참고문헌</h1> <p><a href="https://rinthel.github.io/rust-lang-book-ko/ch04-02-references-and-borrowing.html"> Rust 공식 가이드북 (한글 번역) - 참조자와 빌림</a><br/> <a href="https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/raw-pointers.html">Rust 공식 가이드북 (영문, 1판) - Raw Pointers </a><br/> <a href="https://doc.rust-lang.org/std/ptr/struct.NonNull.html#impl-Pointer-for-NonNull%3CT%3E"> Rust Documentation - <code class="language-plaintext highlighter-rouge">Struct std::ptr::NonNull</code> </a><br/> <a href="https://applied-math-coding.medium.com/an-introduction-into-rust-part-12-box-t-rc-t-and-refcell-t-fae061d2d7fb"> Medium - An Introduction into Rust. Part 12: Box&lt;T&gt;, Rc&lt;T&gt; and RefCell&lt;T&gt; </a><br/> 쿠지라 히코우즈쿠에. (2023). <em>만들면서 배우는 러스트 프로그래밍</em>. (양현, 역). 파주: 위키북스. (원서출판 2022).</p>]]></content><author><name></name></author><category term="rust"/><summary type="html"><![CDATA[Rust에서 포인터처럼 사용할 수 있는 참조자, 원시포인터, Box, Rc, 그리고 RefCell 등에 대해 알아본다]]></summary></entry><entry><title type="html">[Rust] 연결 리스트 구현하기</title><link href="https:/vantaa89.github.io//blog/2023/Rust-Linked-List/" rel="alternate" type="text/html" title="[Rust] 연결 리스트 구현하기"/><published>2023-01-01T16:00:00+00:00</published><updated>2023-01-01T16:00:00+00:00</updated><id>https:/vantaa89.github.io//blog/2023/Rust-Linked-List</id><content type="html" xml:base="https:/vantaa89.github.io//blog/2023/Rust-Linked-List/"><![CDATA[<p>Rust는 소유권과 같은 핵심적인 개념들 때문에 연결리스트(linked list)와 같은 자료형을 구현하기가 까다로운 편이다. 심지어는 <a href="https://rust-unofficial.github.io/too-many-lists/index.html"> Learn Rust With Entirely Too Many Linked Lists </a>같은 책도 있을 정도이다.</p> <p>여기에서는 rust에서 제공하는 포인터 타입 중 하나인 <code class="language-plaintext highlighter-rouge">Box</code>를 이용해 간단한 기능을 갖춘 연결리스트를 구현하였다.</p> <h1 id="node">Node</h1> <p>연결리스트의 핵심은 Node이다. Node는 데이터를 가지고, 또 다음 노드에 대한 포인터를 가져야 한다.</p> <p>먼저 Node를 선언하자.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Copy</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">data</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">next</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span>
<span class="p">}</span>
</code></pre></div></div> <p>data의 경우 <code class="language-plaintext highlighter-rouge">T</code>가 아닌 <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code>로 만들어서 <code class="language-plaintext highlighter-rouge">None</code> 값 또한 가질 수 있도록 해주었다. 우리는 <code class="language-plaintext highlighter-rouge">head</code>를 빈 노드로 처리해 줄 것이기 때문에 이때 특히 유용하게 쓸 것이다. next의 경우에도, 연결 리스트의 끝 노드는 다음 노드를 갖지 않으므로 <code class="language-plaintext highlighter-rouge">None</code>으로 처리해주기 위해 <code class="language-plaintext highlighter-rouge">Option</code>을 사용하였다.</p> <p>새로운 노드의 초기화는 다음과 같이 구현하면 된다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Copy</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nn">Node</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">data</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">next</span><span class="p">:</span> <span class="nb">None</span><span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 뒤에 나올 add(), append(), remove() 등이 모두 여기 들어간다</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="add"><code class="language-plaintext highlighter-rouge">add()</code></h2> <p>현재의 노드에서 i개 후의 노드 뒤에 주어진 데이터를 가진 노드를 추가하는 메서드이다. 뒤에서 나오겠지만 <code class="language-plaintext highlighter-rouge">LinkedList</code>의 <code class="language-plaintext highlighter-rouge">add</code>함수를 위해서 구현해놓은 것이다. Rust에서 포인터를 가지고 iterate하는 것은 너무 어려워서 우선은 재귀적으로 구현했다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span> <span class="p">{</span><span class="n">data</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">next</span><span class="p">:</span> <span class="k">self</span><span class="py">.next</span><span class="nf">.take</span><span class="p">()};</span>
            <span class="k">self</span><span class="py">.next</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">new_node</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.next</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"Index out of range"</span><span class="p">)</span><span class="nf">.add</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">take()</code>는 <code class="language-plaintext highlighter-rouge">Option</code>의 메서드인데, 원본에는 None을 가져다놓고 원본의 소유권을 가져오는 역할을 한다.</p> <h2 id="append"><code class="language-plaintext highlighter-rouge">append()</code></h2> <p>맨 마지막 노드 뒤에 주어진 데이터를 가진 새로운 노드를 추가하는 메서드이다. <code class="language-plaintext highlighter-rouge">self.next</code>에 저장된 것이 <code class="language-plaintext highlighter-rouge">None</code>이 나올 때까지 반복하면 된다. 역시 재귀적으로 정의하였다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">append</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">T</span><span class="p">){</span>
    <span class="k">match</span> <span class="k">self</span><span class="py">.next</span> <span class="p">{</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span> <span class="p">{</span><span class="n">data</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">next</span><span class="p">:</span> <span class="nb">None</span><span class="p">};</span>
            <span class="k">self</span><span class="py">.next</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">new_node</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="nf">Some</span><span class="p">(</span><span class="k">ref</span> <span class="k">mut</span> <span class="n">next</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="n">next</span><span class="nf">.append</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">new_node</code>를 정의한 후 그걸로 <code class="language-plaintext highlighter-rouge">Box</code>를 하나 만들어서 <code class="language-plaintext highlighter-rouge">self.next</code>에 넣어주면 된다.</p> <h2 id="remove"><code class="language-plaintext highlighter-rouge">remove()</code></h2> <p>현재 노드에서부터 <code class="language-plaintext highlighter-rouge">i</code>번째 노드를 제거하는 메서드이다. 마찬가지로 재귀적으로 구현한다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">remove</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="k">self</span><span class="py">.next</span><span class="nf">.take</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"Index out of range"</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">next</span><span class="py">.data</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.next</span> <span class="o">=</span> <span class="n">next</span><span class="py">.next</span><span class="p">;</span> <span class="c1">// link to up next</span>
        <span class="n">ret</span>
    <span class="p">}</span> <span class="k">else</span><span class="p">{</span>
        <span class="k">self</span><span class="py">.next</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.remove</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="get"><code class="language-plaintext highlighter-rouge">get()</code></h2> <p>역시 재귀적으로 구현된, 현재 노드에서부터 <code class="language-plaintext highlighter-rouge">i</code>개 뒤의 노드에 저장된 값을 가져오는 메서드이다. 가능한 범위를 벗어나면 <code class="language-plaintext highlighter-rouge">expect</code>가 에러를 발생시킨다. 여기서 <code class="language-plaintext highlighter-rouge">self.next</code>는 <code class="language-plaintext highlighter-rouge">Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;</code> 타입으로 되어 있는데, 특이하게 <code class="language-plaintext highlighter-rouge">as_ref()</code>를 먼저 해도 Option 안에 있는 <code class="language-plaintext highlighter-rouge">Box&lt;Node&lt;T&gt;&gt;</code>가 <code class="language-plaintext highlighter-rouge">Box&lt;&amp;Node&lt;T&gt;&gt;</code>로 바뀐다. 그 다음에 <code class="language-plaintext highlighter-rouge">expect()</code>로 <code class="language-plaintext highlighter-rouge">Option</code>을 벗겨주면 되는 것 같다. 최종적으로 <code class="language-plaintext highlighter-rouge">next</code>는 <code class="language-plaintext highlighter-rouge">Box&lt;&amp;Node&lt;T&gt;&gt;</code> 타입이 된다. 여기에 dereference를 한번 해주면(<code class="language-plaintext highlighter-rouge">*next</code>) <code class="language-plaintext highlighter-rouge">&amp;Node&lt;T&gt;</code>가, 한번 더 해 주면(<code class="language-plaintext highlighter-rouge">**next</code>) <code class="language-plaintext highlighter-rouge">Node&lt;T&gt;</code>가 될 것이다.</p> <p>그런데, rust는 c++이었으면 <code class="language-plaintext highlighter-rouge">(*next).data</code>을 써주거나 <code class="language-plaintext highlighter-rouge">next-&gt;data</code>와 같이 써줘야 했을 것들을 자동으로 해준다. 따라서 아래 코드에서 <code class="language-plaintext highlighter-rouge">next.data</code>는 실제로는 <code class="language-plaintext highlighter-rouge">(**next.data)</code>를, <code class="language-plaintext highlighter-rouge">next.get(i-1)</code>은 원래 call-by-reference이니 <code class="language-plaintext highlighter-rouge">(*next).data</code>를 의미한다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="k">self</span><span class="py">.next</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"Index out of range"</span><span class="p">);</span>
    <span class="k">match</span> <span class="n">i</span> <span class="p">{</span>
        <span class="mi">0</span> <span class="k">=&gt;</span> <span class="n">next</span><span class="py">.data</span><span class="p">,</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="n">next</span><span class="nf">.get</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h1 id="linkedlist">LinkedList</h1> <p>이제 연결리스트를 구성하는 노드를 구현하였으니, <code class="language-plaintext highlighter-rouge">LinkedList</code>에 필요한 메서드들을 적절하게 구현해주면 된다. 이미 위에서 대부분의 할 일을 다 해두었기 때문에 실제로 구현할 것은 많지 않다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Copy</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">head</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span>
<span class="p">}</span>
</code></pre></div></div> <p>연결리스트는 노드 중 맨 앞에 오는 것, 즉 <code class="language-plaintext highlighter-rouge">head</code>의 주소만 저장해두면 된다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Copy</span><span class="o">&gt;</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nn">LinkedList</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">head</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Node</span><span class="p">{</span><span class="n">data</span><span class="p">:</span><span class="nb">None</span><span class="p">,</span> <span class="n">next</span><span class="p">:</span> <span class="nb">None</span><span class="p">}),</span> <span class="n">size</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// other methods...</span>
<span class="p">}</span>
</code></pre></div></div> <p>맨 앞의 노드(<code class="language-plaintext highlighter-rouge">head</code>)는 더미 노드이다. 연결리스트가 비어있더라도 항상 데이터를 가지지 않는 하나의 노드는 맨 앞에 오게 되어 있다.</p> <p>예외처리만 따로 해주고, <code class="language-plaintext highlighter-rouge">Node</code>의 각 메서드를 그대로 사용해서 다음과 같이 구현하면 된다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Copy</span><span class="o">&gt;</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="k">self</span><span class="py">.size</span> <span class="p">{</span>
            <span class="k">false</span>   <span class="c1">// Index out of range</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.head</span><span class="nf">.add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
            <span class="k">self</span><span class="py">.size</span> <span class="o">=</span> <span class="k">self</span><span class="py">.size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">true</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">append</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">T</span><span class="p">){</span>
        <span class="k">self</span><span class="py">.head</span><span class="nf">.append</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.size</span> <span class="o">=</span> <span class="k">self</span><span class="py">.size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">remove</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="py">.size</span> <span class="p">{</span>
            <span class="nb">None</span>    <span class="c1">// Index out of range</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.size</span> <span class="o">=</span> <span class="k">self</span><span class="py">.size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">self</span><span class="py">.head</span><span class="nf">.remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.head</span><span class="nf">.get</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.size</span>
    <span class="p">}</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.size</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="data-structure"/><category term="rust"/><summary type="html"><![CDATA[Rust로 연결 리스트 구현하기]]></summary></entry><entry><title type="html">[Rust] 최소 힙 구현하기</title><link href="https:/vantaa89.github.io//blog/2022/Rust1927/" rel="alternate" type="text/html" title="[Rust] 최소 힙 구현하기"/><published>2022-12-30T16:00:00+00:00</published><updated>2022-12-30T16:00:00+00:00</updated><id>https:/vantaa89.github.io//blog/2022/Rust1927</id><content type="html" xml:base="https:/vantaa89.github.io//blog/2022/Rust1927/"><![CDATA[<p>새로운 언어를 공부할 때는 무언가를 하나 처음부터 부딪쳐가며 구현해보는게 제일 좋은 것 같다. Rust를 배워보려다가 자료구조도 복습할 겸 힙을 한번 구현해보기로 했다.</p> <p align="center"> <img src="https://upload.wikimedia.org/wikipedia/commons/d/d5/Rust_programming_language_black_logo.svg"/> <br/> Rust </p> <p><a href="https://www.acmicpc.net/problem/1927"> 백준 1927번: 최소 힙</a>을 rust로 풀어보면서 rust의 입출력, 구조체(struct), 제너릭, 소유권 등등 문법을 알아봤다.</p> <h1 id="입출력">입출력</h1> <p>Rust에서 출력은 기본적으로 <code class="language-plaintext highlighter-rouge">println!()</code>을 사용해서 할 수 있다. 다만 이 문제에서는 최악의 경우 10만 줄에 달하는 출력을 해야 하기 때문에 더 빠른 방법을 사용해야 시간초과가 나지 않는다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>     <span class="c1">// string 변수를 정의</span>
<span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buffer</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>   <span class="c1">// 한번에 모든 입력을 받아 저장</span>
<span class="k">let</span> <span class="n">stdout</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nf">stdout</span><span class="p">();</span>  <span class="c1">// 빠른 출력을 위해 사용한다</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">out</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">BufWriter</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">stdout</span><span class="nf">.lock</span><span class="p">());</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">input</span> <span class="o">=</span> <span class="n">buffer</span><span class="nf">.split_ascii_whitespace</span><span class="p">()</span><span class="nf">.flat_map</span><span class="p">(</span><span class="nn">str</span><span class="p">::</span><span class="nn">parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">);</span>

<span class="c1">// 새로운 입력을 사용할 때마다 아래와 같이 받아오면 된다 </span>
<span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
</code></pre></div></div> <h1 id="자료형">자료형</h1> <p>Rust의 자료형에 대해서는 <a href="https://rinthel.github.io/rust-lang-book-ko/ch03-02-data-types.html">공식 가이드북</a>을 참고하면 될 것 같다. C++ 등에서 <code class="language-plaintext highlighter-rouge">char</code>, <code class="language-plaintext highlighter-rouge">short</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">unsigned int</code>, <code class="language-plaintext highlighter-rouge">long</code>, <code class="language-plaintext highlighter-rouge">long long</code>등으로 구분하는 데 비해서 Rust는 좀 더 직관적인 이름으로 자료형을 구분한다. <code class="language-plaintext highlighter-rouge">u32</code>는 32비트 부호없는(unsigned) 정수이고, <code class="language-plaintext highlighter-rouge">i128</code>은 128비트 정수(integer)인 식이다. 부동소수점 또한 <code class="language-plaintext highlighter-rouge">f32</code>, <code class="language-plaintext highlighter-rouge">f64</code>처럼 사용하면 된다. <code class="language-plaintext highlighter-rouge">usize</code>나 <code class="language-plaintext highlighter-rouge">isize</code>의 경우, 사용하는 환경이 32비트인지 64비트인지에 따라 크기가 달라진다. 시스템이 32비트면 32비트, 64비트면 64비트를 갖는다.</p> <p>또, rust의 경우 기본적으로 모든 변수는 immutable으로 정의된다. 선언 후에도 값을 바꾸고 싶다면 <code class="language-plaintext highlighter-rouge">let mut a</code>와 같이 선언해 mutable이라는 것을 알려줘야 한다.</p> <h1 id="optiont">Option&lt;T&gt;</h1> <p><code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code>는 Rust에 특징적으로 존재하는 자료형으로, None이거나 None이 아닐 수 있는 경우를 나타낼 때 사용한다. 예를 들어서 None이거나 부호없는 정수인 변수를 가리키려면</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">a</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
<span class="k">let</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</code></pre></div></div> <p>와 같이 사용할 수 있다. None이 아닌 것은 모두 Some으로 감싸지게 된다.</p> <p><code class="language-plaintext highlighter-rouge">Some(5)</code>는 <code class="language-plaintext highlighter-rouge">Option&lt;usize&gt;</code> 타입이지, <code class="language-plaintext highlighter-rouge">usize</code> 타입은 아니다. <code class="language-plaintext highlighter-rouge">Some(5)</code>에서 5만 빼내서 사용하고 싶다면 <code class="language-plaintext highlighter-rouge">b.unwrap()</code>을 해주면 된다. 또한,</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"The value is None"</span><span class="p">);</span>
</code></pre></div></div> <p>와 같이 expect를 사용하면 <code class="language-plaintext highlighter-rouge">a</code>가 <code class="language-plaintext highlighter-rouge">None</code>일 때 panic이 발생하고 메시지가 출력된다.</p> <h1 id="구조체">구조체</h1> <p>Rust는 객체 지향 언어가 아니다. 따라서 클래스는 없고 구조체를 사용한다. 클래스는 trait이라는 개념을 통해서 비슷하게 사용할 수 있다고 한다. 구조체는 다음과 같이 정의할 수 있다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">MinHeap</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="p">[</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="n">MAX_N</span><span class="p">],</span>
    <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span>
<span class="p">}</span>
</code></pre></div></div> <p>구조체에 포함되는 함수(메서드)는 <code class="language-plaintext highlighter-rouge">impl</code> 안에서 정의해야 한다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">MinHeap</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">MinHeap</span> <span class="p">{</span>
        <span class="n">MinHeap</span> <span class="p">{</span> <span class="n">data</span><span class="p">:</span> <span class="p">[</span><span class="nb">None</span><span class="p">;</span><span class="n">MAX_N</span><span class="p">],</span> <span class="n">size</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>위에서는 생성자를 정의한 것이다. Rust는 기본적으로 모든게 private이기 떄문에 네임스페이스 바깥에서도 사용할 수 있게 하려면 <code class="language-plaintext highlighter-rouge">pub</code>을 앞에 붙여주어야 한다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 객체를 정의해 사용할 때</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">min_heap</span> <span class="o">=</span> <span class="nn">MinHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">min_heap</span> <span class="o">=</span> <span class="n">MinHeap</span> <span class="p">{</span><span class="n">data</span><span class="p">:</span> <span class="p">[</span><span class="nb">None</span><span class="p">;</span><span class="n">MAX_N</span><span class="p">],</span> <span class="n">size</span><span class="p">:</span> <span class="mi">0</span><span class="p">};</span>
</code></pre></div></div> <p>구조체의 인스턴스(객체)를 만들 때는 생성자를 사용하거나, 생성자가 없다면 아래쪽 줄처럼 해주면 된다.</p> <p>전체적으로 C언어에서 사용하는 구조체와 거의 비슷하게 사용하면 되는 것을 알 수 있다. 앞에서 배열을 소개하는 것을 까먹었는데, <code class="language-plaintext highlighter-rouge">[Option&lt;usize&gt;;MAX_N]</code>은 “각 원소가 <code class="language-plaintext highlighter-rouge">Option&lt;usize&gt;</code>의 자료형을 가지는, 길이가 <code class="language-plaintext highlighter-rouge">MAX_N</code>인 배열의 자료형”을 의미한다.</p> <p>그런데 이렇게 정의하면 MinHeap에는 부호 없는 정수만 넣을 수 있게 고정되어 버린다. 아무 자료형으로나 Heap을 만들어 사용하고 싶다면 generic을 사용해야 한다.</p> <h1 id="generic">Generic</h1> <p>C++에서와 거의 비슷하게 “임의의 자료형 T에 대한 자료형”을 정의할 수 있다. 여기에서는 <code class="language-plaintext highlighter-rouge">usize</code>를 저장하는 힙, <code class="language-plaintext highlighter-rouge">f32</code>를 저장하는 힙과 같은 식이다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">MinHeap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="p">[</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="n">MAX_N</span><span class="p">],</span>
    <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span>
<span class="p">}</span>
</code></pre></div></div> <p>위와 같이 정의해주면, 새로운 <code class="language-plaintext highlighter-rouge">MinHeap</code> 객체를 만들 때</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">min_heap</span> <span class="o">=</span> <span class="nn">MinHeap</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
</code></pre></div></div> <p>처럼 정의해주면 된다. 왜 <code class="language-plaintext highlighter-rouge">MinHeap&lt;usize&gt;</code>가 아니라 <code class="language-plaintext highlighter-rouge">MinHeap::&lt;usize&gt;</code>인지는 잘 모르겠다 (ㅎㅎ,,)</p> <h2 id="generic의-bound">Generic의 bound</h2> <p>그런데 힙을 만드려면 아무 자료형 T나 들어와서는 안된다. 힙의 원소가 가지는 자료형은</p> <ul> <li>순서가 있어야 한다. 가장 작은 원소가 루트로 와야 하는데, <code class="language-plaintext highlighter-rouge">T</code>의 두 객체사이에 크고 작음이 정의되지 않다면 힙에 들어갈 수가 없다.</li> <li>Copy를 할 수 있어야 한다.(Copy Trait) 힙에서 원소를 pop할 때, root에 있는 원소의 값을 복사해서 리턴해야 하기 때문이다.</li> </ul> <p>이러한 경우, <code class="language-plaintext highlighter-rouge">T</code>를 우리가 원하는 몇몇 특성을 가진 것들로만 제한해주기 위해서는 다음과 같이 코드를 짜야 한다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">MinHeap</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">PartialOrd</span> <span class="o">+</span> <span class="nb">Copy</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="p">[</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="n">MAX_N</span><span class="p">],</span>
    <span class="n">size</span><span class="p">:</span> <span class="nb">usize</span>
<span class="p">}</span>
</code></pre></div></div> <p>이렇게 하면 <code class="language-plaintext highlighter-rouge">T</code>는 순서가 있고(<code class="language-plaintext highlighter-rouge">PartialOrd</code>), Copy가 가능한(<code class="language-plaintext highlighter-rouge">Copy</code>) 것들로 제한된다.</p> <h1 id="소유권">소유권</h1> <p>Bound를 설명하면서 나온 Copy Trait이라는 말에서 러스트의 굉장히 중요한 특징 중 하나인 <strong>소유권</strong>이라는 개념이 나온다. 예를 들어서</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Hello, World"</span><span class="p">);</span>
<span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</code></pre></div></div> <p>와 같은 코드를 짠다면, 특이하게도 Rust에서는 해당 문자열에 대한 “소유권”이 <code class="language-plaintext highlighter-rouge">a</code>에서 <code class="language-plaintext highlighter-rouge">b</code>로 넘어가버린다. 즉, 더 이상 <code class="language-plaintext highlighter-rouge">a</code>라는 변수로는 문자열에 접근할 수 없는 것이다. 이를 위해서</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="nf">.clone</span><span class="p">();</span>
</code></pre></div></div> <p>과 같이 따로 <code class="language-plaintext highlighter-rouge">.clone()</code>이라는 함수를 사용해 복사를 해줘야 한다. 마치 Deep Copy와도 비슷하다. 그런데, 특정한 데이터 타입에 대해서는 clone을 사용하지 않아도 복사를 잘만 할 수 있다.</p> <ul> <li>정수 타입 (<code class="language-plaintext highlighter-rouge">i64</code> 등)</li> <li><code class="language-plaintext highlighter-rouge">bool</code></li> <li>부동 소수점 타입 (<code class="language-plaintext highlighter-rouge">f32</code> 등)</li> <li>위의 타입들로 구성된 튜플</li> </ul> <p>여기에 해당하지 않는 것들에 대해서는 소유권에 대한 문제를 해결해주기 위해 C와도 유사한 reference를 사용하거나, 위에서 말한 <code class="language-plaintext highlighter-rouge">.clone()</code>을 사용해야 한다.</p> <h1 id="문제-풀이">문제 풀이</h1> <p>위의 내용들을 종합해서 <a href="https://www.acmicpc.net/problem/1927"> 백준 1927번: 최소 힙</a>을 Rust 2018로 풀이한 것이다.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="nn">io</span><span class="p">::{</span><span class="k">self</span><span class="p">,</span> <span class="n">Read</span><span class="p">,</span> <span class="n">Write</span><span class="p">}};</span>
<span class="k">const</span> <span class="n">MAX_N</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">100007</span><span class="p">;</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">PartialOrd</span> <span class="o">+</span> <span class="nb">Copy</span><span class="o">&gt;</span> <span class="n">MinHeap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">MinHeap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nn">MinHeap</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">data</span><span class="p">:</span> <span class="p">[</span><span class="nb">None</span><span class="p">;</span><span class="n">MAX_N</span><span class="p">],</span> <span class="n">size</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="k">self</span><span class="py">.size</span><span class="p">]</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">pivot</span> <span class="o">=</span> <span class="k">self</span><span class="py">.size</span><span class="p">;</span>
        <span class="k">self</span><span class="py">.size</span> <span class="o">=</span> <span class="k">self</span><span class="py">.size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="n">pivot</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">parent</span> <span class="o">=</span> <span class="p">(</span><span class="n">pivot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>   <span class="c1">// index of the parent node</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.data</span><span class="nf">.swap</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span> <span class="c1">// swap method on slices</span>
                <span class="n">pivot</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">pop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">ret</span> <span class="o">=</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>    <span class="c1">// the value to be popped</span>
        <span class="k">self</span><span class="py">.data</span><span class="nf">.swap</span><span class="p">(</span><span class="k">self</span><span class="py">.size</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.size</span> <span class="o">=</span> <span class="k">self</span><span class="py">.size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>      <span class="c1">// decrement the size of the heap</span>
        <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="k">self</span><span class="py">.size</span><span class="p">]</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">pivot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="n">pivot</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.size</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pivot</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pivot</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.size</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.size</span><span class="p">){</span>
                <span class="c1">// pivot has both left and right child</span>
                <span class="k">if</span> <span class="p">(</span><span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">pivot</span><span class="p">]){</span>
                    <span class="k">self</span><span class="py">.data</span><span class="nf">.swap</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">pivot</span><span class="p">);</span>
                    <span class="n">pivot</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">pivot</span><span class="p">]){</span>
                    <span class="k">self</span><span class="py">.data</span><span class="nf">.swap</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">pivot</span><span class="p">);</span>
                    <span class="n">pivot</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="k">break</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">self</span><span class="py">.size</span> <span class="o">==</span> <span class="n">right</span><span class="p">){</span> 
                <span class="k">if</span> <span class="p">(</span><span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">pivot</span><span class="p">]){</span>
                    <span class="k">self</span><span class="py">.data</span><span class="nf">.swap</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">pivot</span><span class="p">);</span>
                    <span class="n">pivot</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="k">break</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">ret</span> <span class="c1">// return은 이렇게 해주면 된다.</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">buffer</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">stdout</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nf">stdout</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">out</span> <span class="o">=</span> <span class="nn">io</span><span class="p">::</span><span class="nn">BufWriter</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">stdout</span><span class="nf">.lock</span><span class="p">());</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">input</span> <span class="o">=</span> <span class="n">buffer</span><span class="nf">.split_ascii_whitespace</span><span class="p">()</span><span class="nf">.flat_map</span><span class="p">(</span><span class="nn">str</span><span class="p">::</span><span class="nn">parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">min_heap</span> <span class="o">=</span> <span class="nn">MinHeap</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>     <span class="c1">// 반복문은 이렇게 해준다. _ 자리에 i가 들어가면 i를 반복문 안에서 사용할 수도 있다</span>
        <span class="k">let</span> <span class="n">query</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">input</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">if</span> <span class="n">query</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">min_heap</span><span class="py">.size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nd">writeln!</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">min_heap</span><span class="nf">.pop</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nd">writeln!</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">"0"</span><span class="p">);</span>
            <span class="p">}</span>
           
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">min_heap</span><span class="nf">.push</span><span class="p">(</span><span class="n">query</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h1 id="참고문헌--도움될-만한-사이트">참고문헌 &amp; 도움될 만한 사이트</h1> <p><a href="https://doc.rust-lang.org/rust-by-example/index.html"> Rust 공식 사이트의 “Rust by Examples” </a><br/> <a href="https://velog.io/@unhappydogchew/러스트-입출력-방법-총정리-Rust로-알고리즘-풀기"> Velog: 러스트 입출력 방법 총정리 - Rust로 알고리즘 풀기</a><br/> <a href="https://rinthel.github.io/rust-lang-book-ko/ch03-02-data-types.html">Rust 공식 가이드북 (한글 번역)</a><br/> <a href="https://seorenn.tistory.com/161"> Rust로 객체지향 프로그래밍 흉내내기 </a><br/> <a href="https://velog.io/@jaenny/자료구조-힙-최소힙-최대힙"> Velog: [자료구조 힙] 최소힙, 최대힙</a></p>]]></content><author><name></name></author><category term="data-structure"/><category term="rust"/><summary type="html"><![CDATA[Rust로 최소 힙을 구현해보면서 기본 문법을 공부해보았다]]></summary></entry><entry><title type="html">NeRF(Neural Radiation Fields) 논문 리뷰</title><link href="https:/vantaa89.github.io//blog/2022/NeRF/" rel="alternate" type="text/html" title="NeRF(Neural Radiation Fields) 논문 리뷰"/><published>2022-12-20T16:00:00+00:00</published><updated>2022-12-20T16:00:00+00:00</updated><id>https:/vantaa89.github.io//blog/2022/NeRF</id><content type="html" xml:base="https:/vantaa89.github.io//blog/2022/NeRF/"><![CDATA[<blockquote> <p>Mildenhall, Ben, et al. “NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis.” Computer Vision–ECCV 2020: 16th European Conference, Glasgow, UK, August 23–28, 2020, Proceedings, Part I. 2020.</p> </blockquote> <p>컴퓨터비전에서 단지 핫한 주제를 넘어 하나의 분야가 되어가고 있다는 NeRF를 제안한 첫 논문으로, ECCV 2020에서 Oral 발표를 하고 Best Paper에 Honorable Mention된 논문이다. 사실 읽은지는 조금 됐는데 종강하고 이제야 정리해서 올린다.</p> <h1 id="abstract--introduction">Abstract &amp; Introduction</h1> <p><strong>NeRF</strong>는 3차원 물체를 여러 각도(view)에서 찍은 사진들을 입력으로 주면, 새로운 각도에서 보았을 때 바라본 모습을 합성(view synthesis)하는 모델이다.</p> <p align="center"> <iframe width="560" height="315" src="https://www.youtube.com/embed/JuH79E8rdKc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br/> NeRF 프로젝트 공식 영상 </p> <p><strong>View Synthesis</strong>를 위해서는 복잡한 기하학적 구조와 각 재질의 반사율(reflectance property) 등을 잘 고려해 처리해줘야 한다. 이 때문에, 현재까지 많은 method들이 제안되어왔지만 충분히 사실적인 품질의 이미지를 생성하는 모델은 존재하지 않았다.</p> <p>NeRF는 이 문제를 뉴럴 네트워크를 사용해 해결하였다. 이때, 비전 문제에 쓰이는 CNN(컨볼루션 신경망)이 아닌, <strong>fully connected network</strong>를 사용한다는 점이 특이한 점이다. 이는 사진들의 집합으로부터 바로 새로운 각도에서의 사진을 합성해내는 것이 아니라, 입력으로 \((x, y, z, \theta, \phi)\) (위치 3차원 + 보이는 각도 2차원)를 받으면 그 위치에서의 <strong>volume density</strong>와 <strong>view-dependent emitting radiance</strong>(RGB 색상)를 출력하도록 모델이 훈련되기 때문이다. 5차원 입력을 받는 연속함수를 근사하는 것일 뿐이므로 CNN을 사용할 이유가 없다. 뉴럴넷을 통해 임의의 방향에서 어떤 바라보았을 때의 빛의 세기나 색을 모두 알 수 있다면 그 물체를 어떤 방향에서 보아도 어떻게 보이는지를 알 수 있을 것이다.</p> <p align="center" style="color:gray"> <img src="/assets/img/NeRF/fig1.jpeg" width="80%"/> </p> <p>NeRF를 훈련시킨 후에 새로운 각도에서 보는 모습을 합성하는 과정은 다음과 같다.</p> <ol> <li>3차원 공간 상의 점들을 샘플링한 후,</li> <li>각 점의 좌표와 그 점에서 물체를 바라보는 각도를 NeRF에 입력으로 넣어준 후</li> <li>출력으로 나온 색깔과 density를 사용해, classical한 렌더링 방법으로 2D 이미지를 구성해 낸다.</li> </ol> <p>이때 volume rendering이라는 문제 자체가 특성상 미분가능할 수밖에 없기 떄문에, 경사하강법(gradient descent)을 사용해 입력 이미지와, NeRF가 렌더링한 이미지 사이의 차이를 최소화하는 방식으로 트레이닝을 하면 된다.</p> <p align="center" style="color:gray"> <img src="/assets/img/NeRF/fig2.jpeg" width="80%"/><br/> Overall pipeline </p> <p>NeRF의 장점은 3차원 공간에 대한 정보를 voxel(픽셀의 3차원 버전)에 저장하는 것이 아니라 뉴럴넷의 가중치로써 저장하기 떄문에 저장공간을 획기적으로 줄일 수 있다는 것이다. 또한, NeRF는 기존의 SOTA(state-of-the-art) 모델과 비교하여 정성적/정량적으로 더 좋은 성능을 보이는 것으로 확인되었다.</p> <h1 id="nerf의-아키텍처">NeRF의 아키텍처</h1> <p>앞서 언급했듯이 NeRF는 5D vector-valued function을 MLP로 근사하여 사용한다. 이는</p> \[F_\Theta : (\mathbf{x, d}) \mapsto (\mathbf{c}, \sigma)\] <p>로 표현할 수 있다. 여기서 \(\mathbf{x}=(x, y, z)\)는 3차원 위치, \(d\)는 바라보는 각도 \((\theta, \phi)\)를 3차원 단위벡터로 나타낸 것이며 출력 \(c\)는 색깔(RGB), \(\sigma\)는 volume density를 나타낸다.</p> <p>주의해야 할 것이, \((x, y, z)\)는 보는 위치, 즉 관찰자의 위치가 아니라 <strong>“관찰당하는 점”의 좌표</strong>라는 것이다. 따라서 volume density \(\sigma\)는 해당 지점의 성질이므로 위치에만 의존하는 함수인 반면, \(c\)는 위치와 각도에 모두 의존하게 된다. 바라보는 각도에 따라서 반사율 등의 효과로 색깔이 달라질 수 있기 때문이다. 이를 고려하기 위해서 NeRF는 아래와 같은 아키텍처를 가진다.</p> <p align="center" style="color:gray"> <img src="/assets/img/NeRF/fig3.png" width="80%"/> <br/> NeRF의 아키텍처. 파란색 계층들은 모두 256개 (또는 128개)의 뉴런으로 구성된 fully connected layer 다음에 ReLU 활성화 함수를 연결한 것이다. (<a href="https://towardsdatascience.com/nerf-representing-scenes-as-neural-radiance-fields-for-view-synthesis-ef1e8cebace4">출처</a>) </p> <p>그림에서 볼 수 있듯이 fully connected layer를 8개 거친 후 NeRF는 \(\sigma\)와 256차원 벡터를 출력한다. \(\sigma\)는 \(\mathbf{d}\) 가 입력으로 들어오기도 전에 출력되므로 각도에 의존하지 않는 상태이다. 256차원 벡터는 다시 각도를 나타내는 \(\mathbf{d}\)와 이어붙여져서(concatenate) 뉴런 128개짜리 fully connected layer를 한번 통과한 후에 RGB 색깔을 출력한다. 따라서 \(\mathbf{c}\)는 각도에 의존하게 된다.</p> <p>\(c\)의 경우, \(\mathbf{x}\)지점에서 \(\mathbf{d}\) 방향으로 방사되는(radiate) 빛의 색과 세기이므로 <strong>directional emitted radiance</strong>라는 이름을 붙일 수 있을 것이다.</p> <h1 id="volume-rendering">Volume Rendering</h1> <p>이제 NeRF를 통해 공간 상의 임의의 지점에서의 volume density \(\sigma\)와 directional emitted radiance \(c\)를 알 수 있게 되었다. 사실 지금까지 volume density \(\sigma\)의 의미가 뭔지 모호했는데, 여기서 그 정의가 제대로 나오게 된다.</p> <p>\(\sigma(\mathbf{x})ds\)는 광선이 \(\mathbf{x}\)를 포함하는 미소길이 \(ds\)만큼의 구간에서 막혀서 사라지는 확률이다. 정의에 의해서 카메라의 렌즈로 들어가는</p> \[\mathbf{r}(t) = \mathbf{o}+ t\mathbf{d} \quad\quad (t_n \le t \le t_f)\] <p>의 광선이 있을 때, 카메라가 이 광선으로부터 느끼는 빛의 세기와 색깔은</p> \[C(\mathbf{r}) = \int_{t_n}^{t_f}T(t) \sigma(\mathbf{r}(t))\mathbf{c}(\mathbf{r}(t), \mathbf{d})dt\quad\text{where}\quad T(t) = \text{exp}\left(-\int_{t_n}^t \sigma(\mathbf{r}(s))ds\right)\] <p>로 계산할 수 있다. 여기서 \(T(t)\)는 accumulated transmittance라는 이름이 붙은 함수이다. 이는 광선이 \(t_n\)에서 \(t\)까지를 어떤 입자와 부딪쳐서 막혀 사라지지 않고 통과할 확률을 의미한다. 적분 안의 항은</p> <ul> <li>그 위치의 입자들이 방사하는 빛의 세기 및 색깔을 나타내는 \(\mathbf{c}(\mathbf{r}(t), \mathbf{d})\)에</li> <li>해당 위치의 volume density \(\sigma(\mathbf{r}(t))\)를 가중치 삼아 곱해준 후</li> <li>그 광선이 카메라가 있는 지점까지 막히지 않고 도달할 확률 \(T(t)\)를 곱한 것</li> </ul> <p>으로 이해할 수 있다. 한편, \(T(t)\)의 경우</p> \[\frac{1}{T}\frac{dT}{dt} = -\sigma(\mathbf{r}(t))\] <p>일 것이므로 어렵지 않게 유도가 가능하다. (\(d\)이 단위벡터이므로 \(\vert d\mathbf{r}\vert = dt\)이다)</p> <p>\(C(\mathbf{r})\)을 적분을 통해 계산하기 위해서는</p> \[t_i \sim U\left[t_n + \frac{i-1}{N}(t_f-t_n), t_n+\frac{i}{N}(t_f-t_n)\right]\] <p>으로 샘플링을 한 후 Riemann sum으로 구분구적법하듯이 적분값을 구하면 된다. (점을 등간격으로 잡는 것도 아니고, 아예 \(U(t_n, t_f)\)에서 \(N\)개를 샘플링하는 것도 아니고 구간을 쪼갠 후 각각에서 랜덤하게 샘플링해주는 이유는 잘 모르겠다.)</p> <p>식으로 나타내자면 다음과 같다.</p> \[\hat{C}(\mathbf{r}) = \sum_{i=1}^N T_i(1-\text{exp}(-\sigma_i \delta_i))\mathbf{c_i}\] \[T_i = \text{exp}\left(-\sum_{j=1}^{i-1}\sigma_j\delta_j\right)\quad\quad \delta_i = t_{i+1}-t_i\] <h1 id="nerf의-훈련">NeRF의 훈련</h1> <p>앞서 이야기한 내용을 정리하자면 다음과 같다.</p> <ul> <li>NeRF는 5D input \((\mathbf{x}, \mathbf{d})\)를 받아서 색깔과 volume density를 내보낸다.</li> <li>이를 volume rendering 테크닉을 이용해 2D 사진으로 구성해낸다.</li> <li>구성해낸 사진과 ground truth의 차이를 구해, loss function으로 삼아 트레이닝시킨다.</li> </ul> <p>그런데 실제로는 이것만으로는 충분히 좋은 해상도의 사진을 얻을 수 없기 때문에 저자들은 두 가지 개선점을 도입하였다.</p> <h2 id="positional-encoding">Positional Encoding</h2> <p>Positional Encoding은 자연어처리에서 많이 사용되는 방법이다. 문장을 Transformer와 같은 모델에 넣어줄 때, 단어간의 순서 관계를 넣어주기 위해서</p> \[\gamma(p) = \left(\sin(2^0\pi p), \cos(2^0\pi p),\cdots, \sin(2^{L-1}\pi p), \cos(2^{L-1}\pi p)\right)\] <p>과 같은 벡터를 더해주는 방법이다.</p> <p align="center" style="color:gray"> <img src="https://d33wubrfki0l68.cloudfront.net/ef81ee3018af6ab6f23769031f8961afcdd67c68/3358f/img/transformer_architecture_positional_encoding/positional_encoding.png" width="80%"/><br/> Positional Encoding을 시각화한 것. 세로축이 p에 해당한다. (<a href="https://kazemnejad.com/blog/transformer_architecture_positional_encoding/">출처</a>) <br/> </p> <p>NeRF에서는 무언가의 순서관계를 위한 것은 아니고, 다른 목적으로 사용된다. 기본적으로 MLP는 연속함수를 근사한다. 우리가 렌더링하려는 물체가 아주 세밀한 구조를 가진다면, 우리의 MLP는 위치와 각도에 따라 출력이 매우 빠르게 변해야 하고(high-frequency variation) 이러한 함수는 MLP가 잘 근사할 수 없게 된다. 이것을 해결하기 위해서 우리는 MLP에 \(\mathbf{x}\)와 \(\mathbf{d}\)를 넣어주는 대신, \(\gamma(\mathbf{x})\)와 \(\gamma(\mathbf{d})\)를 넣어줄 것이다. 이렇게 하면 입력 자체에 \(\mathbf{x}\)와 \(\mathbf{d}\)에 대한 high-frequency term들이 들어가므로, 이들을 적절하게 변환한 결과인 MLP의 출력 또한 high-frequency variation을 잘 표현할 수 있게 된다.</p> <h2 id="hierarchical-sampling">Hierarchical Sampling</h2> <p>ACM 논문 버전에서는 생략했지만, arXiv의 원문을 보면 Hierarchical sampling이라는 것을 도입했다고 언급하고 있다. 간단하게 말하자면, \(t\)를 샘플링하여 \(\hat{C}\)를 계산할 때 위에서 설명한 것처럼 naïve하게 하지 않고 이를 위해 네트워크를 미리 대충(coarsely) 훈련시켜 놓는 것이다. 실제 NeRF의 구현에서는 먼저 coarse network를 위에서 설명한 방식으로 훈련시켜서, 물체의 대략적인 volume density에 대한 정보를 얻는다. 이후 fine network를 트레이닝할 때에는 \(t\)를 샘플링할 때는 coarse network가 알려주는 volume density의 분포를 토대로, volume density가 높은 곳에서는 \(t\)를 많이 샘플링하고 그렇지 않은 곳에서는 적게 샘플링하는 방식을 사용한다. 이를 통해 렌더링을 위해 중요한 부분들을 위주로 샘플링을 함으로써 해상도의 향상을 이루어낼 수 있다.</p> <h1 id="results">Results</h1> <p align="center" style="color:gray"> <img src="/assets/img/NeRF/fig4.jpeg" width="90%"/> <br/> NeRF와 기존 방법들의 정성적 비교. 맨 왼쪽 열이 ground truth(실제), 두 번째가 NeRF의 결과이고 나머지는 기존의 방법들의 결과 사진이다. </p> <p>위 사진에서 볼 수 있듯이 정성적인 비교에서도 NeRF는 기존의 모델들과 비교하여 압도적인 성능을 보여주었으며, 미세한 구조나 섬세한 재질의 표현이 필요한 경우에도 높은 해상도의 이미지를 합성해내는 것을 확인할 수 있었다.</p> <p align="center" style="color:gray"> <img src="/assets/img/NeRF/fig5.jpg" width="90%"/> <br/> NeRF(맨 아래 행)와 기존 방법들의 정량적 비교. pSNR과 SSIM은 높을수록 좋고, LPIPS는 낮을수록 좋은 것이다 </p> <p>정량적 비교에서도 NeRF는기존 SOTA 모델보다 좋은 성능을 보여준다. 또한, 트레이닝하는 데 걸리는 시간이 긴 대신에 하나의 scene에 대한 파라미터들을 저장하는 데 5MB 이하의 메모리만으로 충분하다는 압도적인 장점을 가진다.</p> <h1 id="결론">결론</h1> <p>NeRF는 물체와 그 모습을 MLP를 사용해 연속함수로 근사하려던 기존 방법들의 단점을 해결하여, 공간 상의 좌표와 관찰 각도를 입력으로 받아 view-dependent emitted radiance와 volume density를 출력으로 하는 MLP, <strong>neural radience field(NeRF)</strong>를 정의하였다. 이는 Deep CNN을 사용해 물체를 voxel로 이산적으로 표현하려던 기존의 주류 방법론에 비해 우세한 성능을 보여주었다.</p> <h1 id="참고문헌">참고문헌</h1> <p><a href="https://www.matthewtancik.com/nerf">프로젝트 사이트 </a></p>]]></content><author><name></name></author><category term="deep-learning"/><category term="paper-review"/><summary type="html"><![CDATA[Nerf: Representing scenes as neural radiance fields for view synthesis.]]></summary></entry><entry><title type="html">Flow Model</title><link href="https:/vantaa89.github.io//blog/2022/Flow/" rel="alternate" type="text/html" title="Flow Model"/><published>2022-12-16T10:29:00+00:00</published><updated>2022-12-16T10:29:00+00:00</updated><id>https:/vantaa89.github.io//blog/2022/Flow</id><content type="html" xml:base="https:/vantaa89.github.io//blog/2022/Flow/"><![CDATA[<blockquote> <p>Erneset Ryu 교수님의 2022학년도 2학기 &lt;심층신경망의 수학적 기초&gt; 과목을 듣고 필자가 요약해 정리한 글입니다.</p> </blockquote> <p><strong>Flow model</strong>은 GAN(Generative Adversarial Network)이나 VAE(Variational Autoencoder)와 같은 생성 모델의 하나이다. 두 네트워크가 서로 경쟁하며 생성을 한다는 식으로 비교적 쉽게 이해할 수 있는 GAN과, (적어도 구현할 때) 표면적으로는 어느 정도 와닿는 VAE와 달리 Flow model은 그 수학적 기반을 어느 정도 제대로 이해해야 구현을 할 수 있는 것 같다. 이 때문에 필자도 공부를 해보려다가도 엄두를 못 내고 있었는데, 이번 학기에 &lt;심층신경망의 수학적 기초&gt;를 들으면서 Flow model이 나와서 공부할 기회가 있었다. 수업을 들으면서 배운 내용을 간단하게 정리해보겠다.</p> <h1 id="flow-model이란">Flow Model이란</h1> <p>먼저 Flow model이 무엇인지, 어떤 방법을 사용하는지부터 간단하게 짚고 넘어가보자.</p> <p>Flow model은 <strong>probabilistic generative model</strong>의 하나이다. 주어진 데이터셋 \(X_1, X_2, \cdots, X_N\)이 있다고 하자. 여기서, “나올 수 있는 데이터들의 집합”이라는 것이 있고, 더 나아가서 나올 수 있는 데이터들의 확률분포가 있다고 생각을 해보자. 즉, \(X_1, X_2, \cdots, X_N\)는 \(p_{true}\)라는 확률분포로부터 샘플링을 한 것이 된다.</p> \[X_1, X_2, \cdots, X_N \sim p_{true}\] <p>Flow model과 같은 probabilistic generative model의 목표는 이 확률분포 \(p_{true}\)를 모사하는 것이다. 새로운 샘플 \(X\sim p_{\theta}\)를 만들 수 있도록 하는 새로운 확률분포 \(p_{\theta}\)를 적당히 매개화하여 나타내는 것이 목표가 된다.</p> <p>이러한 공통의 목표를 GAN, VAE, 그리고 Flow model은 다음과 같이 다른 방식으로 수행한다.</p> <p align="center" style="color:gray"> <img src="https://lilianweng.github.io/posts/2018-10-13-flow-models/three-generative-models.png" width="80%"/> <br/> GAN, VAE, 그리고 Flow Model의 비교 (출처: https://lilianweng.github.io/posts/2018-10-13-flow-models/) </p> <p>공통적으로, 세 모델은 모두 입력 데이터 \(X\) 를 <strong>잠재공간(latent space)</strong>상의 벡터 \(Z\) 와 대응시키는 식으로 동작한다. 이떄 잠재공간이란 일종의 차원축소라고도 볼 수 있는데, VAE의 경우를 보면 decoder는 \(Z\)만을 보고도 원래의 \(X\)와 유사한 \(X'\)을 복원해낸다. 이 말은 \(Z\)에 \(X\)에 담겨있는 정보(feature)들이 대부분 담겨있다는 뜻으로도 생각할 수 있을 것이다.</p> <p>눈에 띄는 것은 VAE와 Flow model의 차이이다. VAE에서 encoder와 decoder가 각각 분포를 나타내었고, 두 네트워크가 별개의 가중치를 가졌던 것과 달리(<a href="/blog/2022/VAE/">VAE 포스팅 참고</a>) flow에서는</p> <ol> <li> <p>입력 데이터를 latent space로 보내는, encoder역할을 하는 것이 조건부 확률분포가 아닌 함수 \(f\) 이다. 즉, 하나의 \(X\) 에 대해 \(z\) 가 유일하게, deterministic하게 결정된다.</p> </li> <li> <p>\(f\)는 가역(invertible)이다. 즉, latent vector로부터 데이터를 샘플링하기 위해 별개의 네트워크를 사용할 필요가 없다!</p> </li> <li> <p>VAE에서는 log likelihood 대신 이를 근사하는 ELBO(또는 VLB)를 최대화하였다면, Flow model에서는 log likelihood 그 자체를 최대화한다.</p> </li> </ol> <p>그렇다면 몇 가지 의문점이 생긴다.</p> <ul> <li>잠재벡터 \(Z\)는 왜 필요한 것일까?</li> <li>기존의 컨볼루션, linear layer, ReLU등으로 구성된 신경망은 역변환이 불가능한데, \(f\)를 어떻게 invertible하게 만들 수 있을까?</li> <li>인코더와 디코더를 거친 후 reconstruction loss를 구하면 되는 Autoencoder와 달리, flow model에서는 \(f^{-1}\circ f(X)=X\)가 된다. 그러면 트레이닝은 어떻게 시켜야 할까?</li> </ul> <p>Flow model이 등장한 모티베이션과 그 이론적 배경들을 살펴보면서, 위의 의문점들을 하나씩 해결해보자.</p> <h1 id="maximum-likelihood-estimation">Maximum Likelihood Estimation</h1> <p>앞서 언급했듯이, flow model을 훈련하는 목표는 <strong>maximum likelihood estimation(MLE, 최우도추정)</strong> 을 수행하는 것이다. 분포 \(p_\theta(x)\)에서 나온 표본 \(X_1, X_2, \cdots, X_n\)이 있을 때, 우도(가능도, likelihood)는</p> \[p_\theta(X_1) p_\theta(X_2)\cdots p_\theta(X_n)\] <p>으로 정의된다. 이를 최대화하는 분포 \(p_\theta\)를, 다시 말해 이 분포를 결정하는 매개변수 \(\theta\)를 찾는 것이 바로 최우도추정이다. 이 우도라는 것은 무슨 의미를 가지는 것일까? 앞서 말했듯이, 우리가 flow model을 훈련시키는 목적은 데이터 \(X_1, X_2, \cdots, X_n\)에 내재되어 있는 구조를 파악하는 것이다. 이는 \(p_{true}\)에서 나온 것이므로 이를 근사하는 \(p_{\theta}\)를 구하는 것이 우리의 목표이다.</p> <p>만약 \(p_{\theta}\)가 실제 분포 \(p_{true}\)와 너무 다르다면, \(p_{\theta}\)는 어떤 데이터 \(X_i\)에 대해서 “이런 데이터는 나올 수 없어”라면서 매우 작은 값을 부여할 수도 있을 것이다. 그러면 우도가 매우 작아지게 된다. 따라서 우도가 클수록, 우리의 모델 \(p_{\theta}\)가 실제 분포 \(p_{true}\)에 근접해지는 것이다.</p> <p>그렇다면 각각의 \(X_i\)에 대해서만 \(p_\theta\)값을 크게 하면 되지 않나 하는 생각을 할 수 있을 것이다. 하지만 \(p_{\theta}\)는 확률밀도함수이기 때문에,</p> \[\int p_{\theta}(x) dx = 1\] <p>이라는 기본적인 성질을 만족해야 한다. 즉, \(p_{\theta}\)가 부여할 수 있는 값의 “총량”은 제한되어 있으니, 샘플링된 데이터를 보고 함수값을 잘 배분해서 \(p_{true}\)와 비슷해지도록 하는 것이다.</p> <p>한편, 우도</p> \[p_\theta(X_1) p_\theta(X_2)\cdots p_\theta(X_n)\] <p>는 곱 형태로 되어 있기 떄문에 최대화를 하기가 불편하다. 경사하강법 등을 사용해서 최대화를 수행하려면 식을 미분해야 하는데, 곱 형태로 된 식은 미분이 어렵기 떄문이다. 따라서 로그를 씌워서 <strong>log-likelihood</strong></p> \[\sum_{i=1}^N \log{p_{\theta}(X_i)}\] <p>를 최대화해주게 된다.</p> <h1 id="p_theta의-표현">\(p_{\theta}\)의 표현</h1> <p>그러면 이제 “데이터를 받았을 때, \(p_{\theta}\)에서 \(X_i\)가 나올 확률$$을 neural network를 사용해서 나타내주면 된다. 간단하게 생각하면 이런 방법이 있을 것이다.</p> <blockquote> <p>데이터 X를 입력으로 넣으면 \(p_{\theta}(X)\)를 출력으로 내보내는 신경망</p> </blockquote> <p>그런데 이 방법에는 문제점이 있다. 먼저 정규화(normalization)을 시켜줄 수가 없게 된다. 만약 \(p_{\theta}\)가 이산확률분포였다면, 마지막 계층에 softmax를 한번 씌워주기만 하면 전부 더해서 1이 되도록 강제할 수 있다. 하지만 연속확률분포에서 (1) X를 마구 넣어서 각 X에 대해 \(p_{\theta}(X)\)의 함수값을 구하고 (2) 구분구적법과 같은 방법을 사용해서 적분을 하고 (3) 각각의 함수값을 \(\int p_{\theta}(x)dx\)로 나눠서 정규화하는 것은 굉장히 어려운 작업이다. 따라서 우리는 다른 방법을 써준다. 입력 데이터 \(X\)를 정규분포와 같이 간단한 분포 상의 한 점으로 대응시키는 것이다.</p> <blockquote> <p>데이터 X를 입력으로 넣으면, 이를 간단한 분포 \(p_Z\)상의 \(Z= f_{\theta}(X) \sim p_Z\) 로 대응시키는 신경망</p> </blockquote> <p>이렇게 하면, \(p_{\theta}(x)\)는 자연스럽게 \(p_{\theta}(x)=p_Z(z)= p_Z(f_{\theta}(x))\)로 구할 수가 있게 된다.</p> <p>이는 change of variables formula</p> \[p_{\theta}(X) = \left\vert\frac{\partial z}{\partial x}\right\vert p_{Z}(f_{\theta}(x))\] <p>와 같이 계산된다. 여기서 \(\left\vert\frac{\partial z}{\partial x}\right\vert = \left\vert\frac{\partial f_{\theta}}{\partial x}(x)\right\vert\) 는 Jacobian 행렬의 행렬식(determinant)의 절대값으로, 일종의 부피 변환비같은 역할을 한다.</p> <p>이제 이것을 log likelihood 식에 대입하면 우리의 training objective는 다음과 같다.</p> \[\text{maximize}_{\theta \in \Theta} \sum_{i=1}^N \log{p_{\theta}(X_i)} = \text{maximize}_{\theta \in \Theta} \sum_{i=1}^N \log{p_{Z}(f_{\theta}(X_i))} + \log{\left\vert\frac{\partial f_\theta}{\partial x}(X_i)\right\vert}\] <p>SGD나 Adam같은 optimizer로 위의 최적화를 수행하기만 하면 flow를 훈련시킬 수 있게 되는 것이다. 그런데,</p> \[\log{p_{Z}(f_{\theta}(X_i))} + \log{\left\vert\frac{\partial f_\theta}{\partial x}(X_i)\right\vert}\] <p>의 기울기를 구하고, 샘플링을 통해 새로운 데이터를 얻어내려면 몇 가지 요구사항이 필요하다.</p> <ul> <li>먼저, \(f_{\theta}\)와 \(\nabla_{\theta}f_{\theta}\)를 쉽게 계산할 수 있어야 한다.</li> <li>식에 \(\frac{\partial f_\theta}{\partial x}\)가 나오기 때문에 \(f_\theta\)는 (\(x\)에 대해)미분가능해야 할 것이다.</li> <li>여기에 \(\nabla_{\theta}\)를 씌워서 값을 얻을 수 있어야 하므로,\(\nabla_{\theta}\left\vert\frac{\partial f_\theta}{\partial x}\right\vert\)도 쉽게 계산이 가능해야 한다.</li> <li>마지막으로, sampling을 하기 위해서는 \(f_{\theta}\)가 가역(invertible)이어야 한다. <ul> <li>부연설명을 하자면, 여기서 sampling이란 우리가 근사한 분포 \(p_{\theta}\)로부터 새로운 데이터를 얻어내는 것을 말한다. 이는 \(Z\sim p_Z\)를 하나 샘플링 한 후 \(f^{-1}_\theta(Z)\)를 구함으로써 가능하다. \(f_{\theta}\)가 가역이어야 하는 이유이다.</li> </ul> </li> </ul> <h2 id="flow의-합성">Flow의 합성</h2> <p>기존의 MLP(다층 퍼셉트론)나 CNN(컨볼루션 신경망)에서 층을 여러 개 쌓아서 네트워크의 표현력을 증가시켰듯이, flow에서도 비슷하게 flow를 여러 층으로 쌓아 합성함수를 구성하듯이 표현력을 증가시킬 수 있다. 단순히</p> \[x \mapsto f_1 \mapsto f_2 \mapsto \cdots \mapsto f_n \mapsto z\] <p>와 같이 여러 함수들을 거쳐서 \(x\)가 간단한 분포 \(p_Z\)를 따르는 확률변수로 변환되는 것이다. 이 경우 체인 룰을 사용해서</p> \[\left\vert \frac{\partial f_{\theta}}{\partial x}\right\vert = \left\vert \frac{\partial f_n}{\partial f_{n-1}}\frac{\partial f_{n-1}}{\partial f_{n-2}}\cdots \frac{\partial f_2}{\partial f_1}\frac{\partial f_1}{\partial x}\right\vert\] \[= \left\vert \frac{\partial f_n}{\partial f_{n-1}}\right\vert\left\vert\frac{\partial f_{n-1}}{\partial f_{n-2}}\right\vert\cdots \left\vert\frac{\partial f_2}{\partial f_1}\right\vert\left\vert\frac{\partial f_1}{\partial x}\right\vert\] <p>임을 알 수 있으므로,</p> \[\log p_\theta(x) = \log p_Z(f_\theta(x))+\sum_{i=1}^n \log \left\vert \frac{\partial f_i}{\partial f_{i-1}}\right\vert\] <h1 id="coupling-flow">Coupling Flow</h1> <p>이제 처음에 들었던 세 가지 의문점 중 첫 번째와 세 번째가 해결되었다. 그렇다면 마지막, 두 번째 의문점이 남는다.</p> <ul> <li>기존의 컨볼루션, linear layer, ReLU등으로 구성된 신경망은 역변환이 불가능한데, \(f\)를 어떻게 invertible하게 만들 수 있을까?</li> </ul> <p>일반적으로, 이를 위해서 사용하는 방법은 <strong>coupling flow</strong>이다. 이를 간단하게 설명하자면, 각 층의 입력 \(x\)를 \(x = (x^A\vert x^B)\)로 분할한 후 \(x^B\)만 변환하고 \(x^A\)는 그대로 남겨두는 것이다. 수식으로 이를 설명하자면 다음과 같다.</p> \[z = (z^A\vert z^B) = f(x) = f(x^A\vert x^B) = (x^A\vert \hat{f}(x^B\vert \psi_\theta (x^A)))\] <p>식을 보면, \(x^B\)를 변환하는 함수는 \(\hat{f}(x^B\vert \psi_\theta (x^A))\)로 표현된다는 것을 알 수 있다. 즉, \(x^A\)로부터 \(\psi_\theta (x^A)\)라는 값을 얻은 후, \(x^B\)를 변환할 때 이를 참고해서 사용한다는 것으로 해석하면 된다. 또, \(\hat{f}\)는 가역이라는 조건이 붙는다.</p> <p>이렇게 하면 \(z\)만 보고 \(x\)를 쉽게 얻어낼 수 있다! 먼저 \(z^A = x^A\)이므로 \(x^A\)는 바로 얻어낼 수 있다. \(x^B\)만 얻어내면 되는 것인데, 이는 다음의 과정으로 계산이 가능하다.</p> <ol> <li>먼저 \(\psi(x^A)=\psi(z^A)\)를 구한다.</li> <li>\(z^B = \hat{f}(x^B\vert\psi(x^A))\)이고, \(\hat{f}\)는 가역이며, \(\psi(x^A)\)를 알고 있으니 함수의 역을 취해서 \(x^B\)를 얻어낼 수 있다.</li> </ol> <p>즉, \(f\)는 가역 함수가 된다. 가역함수끼리 합성해도 가역함수가 되므로, 이러한 \(f\)를 앞서 설명한 것처럼 거듭해 쌓으면 더 강력한 표현력을 가진 flow를 얻을 수 있다. 한편, coupling flow의 Jacobian determinant \(\left\vert\frac{\partial f_\theta}{\partial x}\right\vert\)를 구하면 다음과 같다.</p> \[\left\vert\frac{\partial f_\theta}{\partial x}\right\vert = \left\vert \frac{\partial \hat{f}}{\partial x^B}(x^B\vert \psi_{\theta}(x^A))\right\vert\] <h2 id="additive-transformation-nice">Additive Transformation (NICE)</h2> <p>L. Dinh et al. (2014), “Nice: Non-linear independend components estimation”에서 사용한 방법이다. 단순히</p> \[z_{1:n/2} = x_{1:n/2}, z_{n/2:n} =x_{n/2:n} = x_{n/2:n }+t_\theta(x_{1:n/2})\] <p>로 정의하는 방식이다. 즉, 입력 데이터의 앞부분 절반은 변형 없이 그대로 내보내고, 나머지 절반은 앞부분으로부터 얻은 어떤 함수값을 더해주기만 하는 방식이다. 이 경우 inverse는</p> \[x_{1:n/2} = z_{1:n/2}, x_{n/2:n} =z_{n/2:n} = x_{n/2:n }-t_\theta(z_{1:n/2})\] <p>로 쉽게 계산할 수 있게 되고, Jacobian determinant는 \(\left\vert\frac{\partial f_\theta}{\partial x}\right\vert = 1\)이 된다.</p> <h2 id="affine-transformation-real-nvp">Affine Transformation (Real NVP)</h2> <p>L. Dinh et al. (2016), “Density estimation using real nvp”에서 사용된 방법이다. Real NVP에서 NVP는 non-volume-preserving의 약자로, 일종의 부피변화율의 의미를 갖는다고 한 Jacobian determinant가 NICE에서와는 다르게 1이 아니게 된다는 점에서 따온 말인 것으로 보인다. (논문을 읽지는 않아서 정확히는 모르겠다)</p> <p>Real NVP에서는 한발 더 나아가,</p> \[z_{1:n/2} = x_{1:n/2},\quad z_{n/2:n} =e^{s_\theta(x_{1:n/2})} \odot x_{n/2:n} +t_\theta(x_{1:n/2})\] <p>와 같이 계산이 이루어진다. 여기서 \(\odot\)은 elementwise multiplication을 의미한다. inverse는 (당연히)</p> \[x_{1:n/2}=z_{1:n/2}, \quad x_{n/2:n} = e^{-s_\theta(x_{1:n/2})}\odot (z_{n/2:n}-t_\theta(x_{1:n/2}))\] <p>로 계산할 수 있다. Jacobian determinant는 앞서 말했듯이 1이 아니게 되고, 게산을 해보면</p> \[\left\vert\frac{\partial f_\theta}{\partial x}\right\vert = \prod_{i}e^{s_\theta(x_{1:n/2})_i}=\text{exp}(\mathbb{1}_{n/2}^T s_{\theta}(x_{n/2:n}))\] <p>이 된다.</p> <h2 id="coupling-layer의-분할-방법">Coupling Layer의 분할 방법</h2> <p>위에서 \(x = (x^{A}, x^B)\)와 같이 분할할 때, 분할하는 방법을 계속 똑같이 둔다면 \(x^A\)에 해당하는 원소(픽셀)들은 계속 값이 바뀌지 않은 채로 놓이게 될 것이다. 따라서 일반적으로 flow model들에서는 각 계층마다 분할을 하는 방법을 계속 바꿔준다.</p> <p style="color:gray" align="center"> <img src="/assets/img/realnvp_masks.png" width="80%"/> <br/> coupling layer의 분할 방법. 좌: spatial checkerboard. 우: channelwise. 출처: L. Dinh et al. (2016) </p> <p>첫 번째 방법은 위의 왼쪽 그림처럼 checkerboar pattern으로 A와 B를 구분해주는 방법이다. 반면 두 번째 방법은 텐서를 reshape해준 후, 채널별로 A와 B를 구분해주는 방법이다. Real NVP의 경우 두 가지 방법을 교대로 3번씩 사용해주는 방식으로 충분한 표현력을 얻을 수 있도록 한다.</p> <h1 id="결론">결론</h1> <p>이제 글의 초반에 던졌던 세 가지 질문에 대한 답을 정리해보겠다.</p> <ul> <li>잠재벡터 \(Z\)는 왜 필요한 것일까? <ul> <li>각 데이터 \(X\)의 우도를 계산할 때, 뉴럴 네트워크가 곧바로 PDF를 출력하도록 하기에는 (1) normalization이 힘들고, (2) sampling이 어렵다는 문제점이 있다. flow에서는 이를 해결하기 위해서 주어진 데이터의 확률분포를 정규분포와 같은 간단한 분포로 매핑하는 함수 \(f_\theta\)를 정의하는데, 이것에 의해 입력 데이터 \(X_i\)는 잠재벡터 \(Z=f_\theta(X_i)\)로 매핑된다.</li> </ul> </li> <li>기존의 컨볼루션, linear layer, ReLU등으로 구성된 신경망은 역변환이 불가능한데, \(f\)를 어떻게 invertible하게 만들 수 있을까? <ul> <li>Coupling Flow를 사용해서 텐서를 두 부분으로 분할한 후, 절반은 그대로 두고 나머지 절반은 “첫번째 절반과의 correlation이 들어간” 가역 변환을 취해준다. NICE에서는 Additive Transformation을, Real NVP에서는 Affine Transformation을 사용한다.</li> </ul> </li> <li>인코더와 디코더를 거친 후 reconstruction loss를 구하면 되는 Autoencoder와 달리, flow model에서는 \(f^{-1}\circ f(X)=X\)가 된다. 그러면 트레이닝은 어떻게 시켜야 할까? <ul> <li>Maximum likelihood estimation을 트레이닝의 목표로 삼아, log likelihood을 최대화시킴으로서 트레이닝이 가능하다.</li> </ul> </li> </ul>]]></content><author><name></name></author><category term="deep-learning"/><category term="MathDNN"/><summary type="html"><![CDATA[Flow model에 대한 설명]]></summary></entry><entry><title type="html">Variational Autoencoder</title><link href="https:/vantaa89.github.io//blog/2022/VAE/" rel="alternate" type="text/html" title="Variational Autoencoder"/><published>2022-11-18T15:00:00+00:00</published><updated>2022-11-18T15:00:00+00:00</updated><id>https:/vantaa89.github.io//blog/2022/VAE</id><content type="html" xml:base="https:/vantaa89.github.io//blog/2022/VAE/"><![CDATA[<blockquote> <p>Erneset Ryu 교수님의 2022학년도 2학기 &lt;심층신경망의 수학적 기초&gt; 과목을 듣고 필자가 요약해 정리한 글입니다.</p> </blockquote> <h1 id="introduction">Introduction</h1> <p>Variational Autoencoder에 대해 설명하기 전에, 그 전단계인 Autoencoder에 대해 알아보고 넘어가자. <strong>Autoencoder</strong>는 이미지처럼 높은 차원의 입력 데이터를 잠재 공간(latent space)상의 저차원의 표현 벡터로 압축하는 <strong>인코더</strong>와, 다시 잠재 공간의 벡터를 원본으로 복원하는 것을 목표로 하는 <strong>디코더</strong>로 구성된 신경망이다. 인코더의 입력과 디코더의 출력의 차이(예를 들어 MSE)를 손실 함수로 설정함으로써, 인코더는 원본 이미지의 특성을 잘 살려서 벡터로 표현하는 방법을 학습하게 되고, 디코더는 표현 벡터만을 보고 원본 이미지에 가깝게 복원하는 방법을 학습하게 된다.</p> <p>여기서 디코더가 <strong>표현 벡터만을 보고 원래의 이미지를 복원</strong>해낸다는 점에 주목하자. 즉, 표현 벡터에는 원래 이미지의 중요한 정보들이 다 담겨있다는 것이다. 즉, 표현벡터는 원본 이미지에 담긴 특성(feature)들을 뽑아 저장해놓은 차원 축소의 역할을 한다고도 볼 수 있을 것이다. 실제로 VAE를 데이터의 차원을 축소하는 데 사용하는 경우가 많다.</p> <p align="center" style="color:gray"> <img src="/assets/posts/2022-11-19-VAE/image.png" width="80%" height="80%"/> <br/> VAE의 기본 구조. Autoencoder의 경우에도 같은 형태를 가진다. </p> <p>Variational Autoencoder는 Autoencoder에 확률적인 개념을 더해 개선한 것이다. 이 글에서는 VAE가 왜 타당한 모델인지, 그 motivation은 어디에서 나왔는지를 수학적으로 설명한 부분들을 정리해보려고 한다.</p> <h1 id="key-idea-of-vae">Key Idea of VAE</h1> <p>Variational Autoencoder는 크게 latent vector \(Z\) 가 주어졌을 때, 이미지의 확률분포를 나타내는 <strong>인코더</strong> \(q_\phi(z\vert x)\)와, 이미지 \(x\) 가 주어졌을 때 latent vector \(Z\)의 분포를 설명하는 <strong>디코더</strong> \(p_\theta(x\vert z )\)의 두 부분으로 구성된다. Autoencoder를 이해했다면 왜 저 두 함수가 각각 인코더와 디코더로 불리는지 쉽게 이해할 수 있겠지만 우선은 ‘인코더, 디코더’라는 명칭에 대해서는 넘어가기로 하자. 여기에서는 왜 저 두 함수가 필요한지를 조금 다른 motivation을 사용해 설명할 것이다.</p> <h2 id="목표-maximum-likelihood-estimation">목표: Maximum Likelihood Estimation</h2> <p>먼저, \(N\)개의 이미지(예를 들어서 \(N\)장의 고양이 사진) \(X_1, X_2, \cdots, X_N\) 가 주어져 있다고 생각하자. 우리의 목표는 이러한 고차원의 이미지들의 기저에 있는, underlying structure를 이해하는 것이다. 다르게 말하자면, \(N\)장의 고양이 사진들은 “고양이 사진의 확률분포”에서 \(N\) 번 샘플링된 것이라고 가정할 수 있으며, 그 확률밀도함수 \(p_X(x)\) 를 알아내는 것을 목표로 삼을 수 있을 것이다.</p> <p>이는 늘 그렇듯이 <strong>최우도추정(maximum likelihood estimation, MLE)</strong> 을 통해서 할 수 있다. IID로 \(p_X(x)\)에서 샘플링을 했을 때, 저 N개의 이미지가 모두 나올 확률(정확히는 likelihood)은 \(p_X(X_1)p_X(X_2)\cdots p_X(X_n)\) 가 되므로 이를 최대화하면 되는 것이다. 곱으로 이루어진 식은 다루기 어려우므로 로그를 씌우면 우리의 목표는 \(\text{maximize}_{p} \sum_{i=1}^N\log p(X_i)\) 가 된다. \(p\)라는 함수가 \(\theta\)로 매개화되는 함수라고 하면, 다시</p> \[\text{maximize}_{\theta \in \Theta} \sum_{i=1}^N\log p_\theta(X_i)\] <p>로 쓸 수 있을 것이다. 이때 \(p_\theta\) 는 신경망으로 구현되며, \(\theta\) 는 그 가중치가 될 것이다.</p> <p>그런데 autoencoder에서 설명했듯이 이미지 \(X\) 에는 그 기저에 \(Z\) 라는, 이미지의 특성을 설명하는 변수가 있어 \(Z\) 만 알면 \(X\) 가 거의 결정된다고 할 수 있다. 따라서 전확률공식과 조건부확률을 사용해서</p> \[p_\theta(X) = \int p_\theta(X|z)p_Z(z) dz = \mathbb{E}_{Z \sim p_Z}[p_\theta(X|Z)]\] <p>로 쓸 수 있다. 그러면 다시 우리의 목표는</p> \[\text{maximize}_{\theta \in \Theta} \sum_{i=1}^N \log \mathbb{E}_{Z \sim p_Z}[p_\theta(X_i|Z)]\] <p>로 바뀌게 된다. \(p_Z\) 는 여기서 알려져있는 함수로, 일반적으로 (다변수) 표준정규분포를 사용한다.</p> <h2 id="importance-sampling">Importance Sampling</h2> <p>이제 위의 식을 어떻게 최대화할지를 생각해봐야 할 것이다. 여기서 문제점은 식에 기댓값이 끼어있다는 것이다. \(Z\) 가 이산확률변수라면 그냥</p> \[\mathbb{E}_{Z \sim p_Z}[p_\theta(X|Z)]=\sum_i p_Z(z_i)p_\theta(X|z_i)\] <p>처럼 다 더해버리면 된다. 하지만 \(Z\) 는 연속적인 분포를 가지기 때문에 \(\int p_\theta(X\vert z)p_Z(z) dz\) 를 계산해야 하며, 이는 굉장히 어렵다. 이 때문에 \(Z_i\) 를 샘플링해서 \(\mathbb{E}\) 의 근사값을 구해 사용하게 된다.</p> \[\sum_{i=1}^N \log \mathbb{E}_{Z \sim p_Z} [p_\theta(X_i|Z)] \approx \sum_{i=1}^N \log p_\theta(X_i|Z_i)\quad\quad Z_i \sim p_Z\] <p>사실 위의 식은 각 이미지 \(X_i\) 에 대해서, 그 이미지를 만들어낸(만들어냈을 것이라고 생각되는) latent vector \(Z\) 를 한개씩만 샘플링하여 구하기 때문에 매우 부정확한 근사이다. 따라서 우리는 <strong>Importance Sampling</strong> 이라는 개념을 도입해서 이를 해결한다.</p> <h3 id="importance-sampling의-개념">Importance Sampling의 개념</h3> <p>\(X\) 가 \(f(x)\) 라는 확률밀도함수를 가질 때 \(\mathbb{E}_{X\sim f}[\phi(X)]\) 를 구해야 하는 상황을 생각해보자. 그런데 적분을 실제로 해서 이를 구하는 것이 어려운 상황이 많기 때문에 위와 같이 많은 경우 \(X\) 를 적당히 샘플링해서</p> \[\mathbb{E}_{X\sim f}[\phi(X)]\approx \frac{1}{N}\sum_{i=1}^k \phi(X_i)\] <p>과 같이 근사해서 사용한다. 이를 <strong>Monte Carlo Estimation</strong> 이라고 한다. 큰 수의 법칙에 의해, \(N\)이 커지면 커질수록 우변은 실제 기대값과 매우 유사한 값을 가지게 될 것이다.</p> <p>하지만 위와 같은 근사는 때때로 분산이 너무 커서 실제로는 사용하기 힘들거나, \(N\)이 아주 커야 정확해질 때가 많다. 따라서 <strong>Importance Sampling</strong> 이라는 개념을 사용해서 분산을 줄이게 된다. Importance Sampling의 핵심은 X의 분포 함수 \(f\)를 다른 “좋은” 함수 \(g\)로 바꾸는 것이다. 이를 위해 아래와 같은 테크닉을 사용한다.</p> \[\mathbb{E}_{X\sim f}[\phi(X)] = \int \phi(x) f(x) dx = \int \frac{\phi(x)f(x)}{g(x)} g(x) dx\] <p>이는 기대값을 사용해 아래와 같이 쓸 수 있다.</p> \[\mathbb{E}_{X\sim f}[\phi(X)] = \mathbb{E}_{X \sim g}\left[\frac{\phi(X)f(X)}{g(X)} \right]\] <p>앞서 말했듯이, \(X\) 가 따르는 분포(확률밀도함수)가 \(f\) 에서 \(g\)로 바뀐 것을 볼 수 있을 것이다. \(g\)를 적절하게 선택하면 원래보다 더 정확한(variance가 낮은) 추정을 할 수 있게 된다.</p> <p>그러면 \(g\)는 어떻게 선택해야 할까? 이상적으로는</p> \[g(X) = \frac{\phi(X)f(X)}{I} \quad(I = \int \phi(x) f(x) dx)\] <p>로 놓으면 분산이 0으로 최소가 된다. 그런데 \(I\)는 우리가 알고 있는 값이 아니므로(\(I = \mathbb{E}_{X\sim f}[\phi(X)]\)이므로 \(I\)를 알고 있다면 애초에 이 짓을 할 필요가 없다) 이러한 함수는 우리가 사용할 수 없다.</p> <p>따라서 \(g\)가 이상적인 함수 \(\frac{\phi(X)f(X)}{I}\)와 갖는 거리를 구해서, 이것이 최소화되도록 함으로써 어느 정도 좋은 \(g\) 를 구할 수 있다. \(g\) 는 \(\theta\) 로 parametrize된 신경망으로 구성되어 있다고 가정하자. KL-Divergence를 사용하면,</p> \[D_{KL} (g_\theta||\phi f/I) = \mathbb{E}_{x\sim g_\theta}\left[{\log\left(\frac{Ig_\theta (X)}{\phi(X)f(X)}\right)}\right]\\ = \mathbb{E}_{x\sim g_\theta}\left[{\log\left(\frac{g_\theta (X)}{\phi(X)f(X)}\right)}\right] + \log I\] <p>이며, \(\log I\)는 \(\theta\)에 대해서는 상수이므로</p> \[\mathbb{E}_{x\sim g_\theta}\left[{\log\left(\frac{g_\theta (X)}{\phi(X)f(X)}\right)}\right]\] <p>를 SGD를 사용해서 최소화하면 된다. 이렇게 구한 \(g_\theta\)를 사용하여 Importance Sampling을 하면 \(I\)를 비교적 낮은 variance로 추정할 수 있다.</p> <h3 id="z를-importance-sampling하자">Z를 importance sampling하자</h3> <p>이제 원래의 문제로 돌아와서, 이미지 \(X_i\)에 대해</p> \[p_\theta(X_i) =\mathbb{E}_{Z \sim p_Z} [p_\theta(X_i|Z)]\] <p>를 \(Z_i\sim q_i(z)\)를 사용한 importance sampling을 통해 근사해 보자.</p> \[\mathbb{E}_{Z \sim p_Z} [p_\theta(X_i|Z)] \approx p_\theta(X_i|Z_i)\frac{p_Z(Z_i)}{q_i(Z_i)}\quad \quad Z_i \sim q_i(z)\] <p>이때 \(q_i\)는 앞서 설명한 것과 마찬가지로</p> \[q_i^*(z) = \frac{p_\theta(X_i|z)p_Z(z)}{p_\theta(X_i)} = p_\theta(z|X_i)\] <p>일 때 최대가 될 것이다. 그런데 베이즈 정리에 의해서, 이는 \(p_\theta(z\vert X_i)\)와 같다. 물론 이는 정확하게 계산이 불가능하며(\(p_\theta(X_i)\)를 모르니), KL-Divergence 를 통해 \(q_i^*\)와 최대한 비슷한 \(q_i\)를 찾아야 한다.</p> \[D_{KL}(q_i(\cdot) || q_i^*(\cdot))\] \[= D_{KL}(q_i(\cdot) || p_\theta(\cdot|X_i))\] \[= \mathbb{E}_{Z\sim q_i}\log\left(\frac{q_i(Z)}{p_\theta(Z|X_i)} \right)\] \[=\mathbb{E}_{Z\sim q_i}\log\left(\frac{q_i(Z)}{p_\theta(X_i|Z)p_Z(Z)/p_\theta(X_i)} \right)\] \[=\mathbb{E}_{Z\sim q_i} [\log(q_i(Z)) - \log(p_\theta(X_i|Z))-\log p_Z(Z) ]+ \log p_\theta(X_i)\] <p>마지막 줄에서, \(\log p_{\theta}(X_i)\)는 \(Z\)와 무관한 항이므로 최소화할 때 무시해줘도 된다. 그러면 \(q_i(Z), p_{\theta}(X_i\vert Z), p_Z(Z)\)는 모두 우리가 계산할 수 있는 항들이므로 \(q_i\)를 잘 조절함으로써 최소화가 가능하다.</p> <h3 id="amortized-inference">Amortized Inference</h3> <p>그런데 위에서 \(q_i\)를 보면 index \(i\)가 붙어있는 것을 알 수 있다. 즉, 각 데이터(이미지) \(X_i\)에 대해서 개별적으로 최적화 문제를 풀고 있는 것이다. 당연히 이는 계산이 매우 많이 걸릴 것이다.</p> <p>따라서 우리는 함수 \(q\)를 신경망으로 구성하고, 그 가중치 \(\phi\)로 parametrize하여 \(q_\phi\)로 만든다. 그리고</p> \[\sum_{i=1}^ND_{KL}(q_\phi(\cdot|X_i) || q_i^*(\cdot))\] <p>를 loss 함수로 삼아서 SGD를 사용해 최소화한다. 이렇게 하면, \(q_\phi\)는 넣어주는 이미지 \(X_i\)에 따라서 다른 분포 \(q_i(z)\)를 나타내게 된다. 즉 하나의 함수 \(q_\phi(z\vert X)\)만으로 \(N\)개의 계산과정을 대신할 수 있는 것이다. 즉,</p> \[q_\phi(z|X_i) = q_i(z) \approx q_i^*(z) = p_\theta(z|X_i)\quad \text{for all } i = 1, \cdots, N\] <p>가 되는 것이다. 이 \(q_\phi\)가 바로 인코더가 된다.</p> <h1 id="encoder와-decoder의-최적화">Encoder와 Decoder의 최적화</h1> <p>이제 인코더 \(q_\phi\)와 \(p_\theta\)를 최적화하면 된다. 먼저 인코더의 목표는 앞에서 설명한 것처럼 각 이미지 \(X_i\)에 대해 importance sampling을 하는 최적의 함수 \(q_i^*\)를 amortized inference로 근사하는 것이 된다.</p> \[\text{minimize}_{\phi\in\Phi}\sum_{i=1}^ND_{KL}(q_\phi(\cdot|X_i) || q_i^*(\cdot))\] \[= \text{maximize}_{\phi\in\Phi} \sum_{i=1}^N \mathbb{E}_{Z\sim q_\phi(z|X_i)}\log\left(\frac{q_i(Z)}{p_\theta(Z|X_i)} \right)\] \[= \text{maximize}_{\phi\in\Phi}\mathbb{E}_{Z\sim q_\phi(z|X_i)} \left[\log\left(\frac{p_\theta(X_i|Z)p_Z(Z)}{q_\phi(Z|X_i)}\right) \right]\] \[= \text{maximize}_{\phi\in\Phi}\sum_{i=1}^N \mathbb{E}_{Z\sim q_\phi(z|X_i)}[\log p_\theta(X_i|Z)-D_{KL}(q_\phi(\cdot|X_i)||p_Z(\cdot))]\] <p>디코더의 목표는 (당연히) Maximum Likelihood Estimation을 수행하는 것이다.</p> \[\text{maximize}_{\theta\in\Theta}\sum_{i=1}^N \log p_\theta(X_i)\] \[= \text{maximize}_{\theta\in\Theta} \log\mathbb{E}_{Z\sim p_Z}\left[p_\theta(X_i|Z)\right]\] \[\approx\text{maximize}_{\theta \in\Theta} \sum_{i=1}^N \log\left(\frac{p_\theta(X_i|Z)p_Z(Z)}{q_\phi(Z|X_i)} \right)\quad (Z\sim q_{\phi}(z|X_i))\] \[\approx\text{maximize}_{\theta \in\Theta} \sum_{i=1}^N \mathbb{E}_{Z_\sim q_{\phi}(z|X_i)}\left[\log\left(\frac{p_\theta(X_i|Z)p_Z(Z)}{q_\phi(Z|X_i)} \right)\right]\] \[= \text{maximize}_{\theta \in\Theta} \sum_{i=1}^N \mathbb{E}_{Z_\sim q_{\phi}(z|X_i)} \left[\log p_\theta(X_i|Z)\right] - D_{KL}(q_\phi (\cdot|X_i)||p_Z(\cdot))\] <p>우연히도 두 식의 형태가 똑같은 것을 알 수 있다! 따라서 위 식을 최대화하는 \(\theta\)와 \(\phi\)를 찾으면 된다. 즉,</p> \[\text{maximize}_{\theta \in\Theta, \phi \in \Phi} \sum_{i=1}^N \mathbb{E}_{Z_\sim q_{\phi}(z|X_i)} \left[\log p_\theta(X_i|Z)\right] - D_{KL}(q_\phi (\cdot|X_i)||p_Z(\cdot))\] <p>를 찾는 것이 VAE의 training objective가 된다.</p> <h2 id="standard-vae-setup">Standard VAE setup</h2> <p>이제 표준적인 setup의 VAE에서 일반적으로 사용하는</p> \[p_Z = N(0, I),\quad q_\phi(z\vert x) = N(\mu_\phi(x), \Sigma_\phi(x)), \quad p_\theta(x\vert z) = N(f_\theta(x), \sigma^2 I)\] <p>의 확률분포들을 대입해주자. 이때 \(\Sigma_\phi\)는 대각행렬으로 한다. 그러면,</p> <p>다변수 정규분포의 확률밀도함수</p> \[p_X(x) = \frac{1}{(2\pi)^{k/2}} e^{-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)}\] <p>에 의해서(\(X \sim N(\mu, \Sigma)\), \(X\) 는 \(k\) 차원), 위의 training objective는</p> \[\text{maximize}_{\theta \in\Theta, \phi \in \Phi} \sum_{i=1}^N \mathbb{E}_{Z_\sim q_{\phi}(z|X_i)} \left[-\frac{1}{2\sigma^2} \vert\vert X_i - f_\theta(Z)\vert\vert^2\right] - D_{KL}(q_\phi (\cdot|X_i)||N(0, I))\] \[= \text{minimize}_{\theta \in\Theta, \phi \in \Phi} \sum_{i=1}^N \mathbb{E}_{Z_\sim q_{\phi}(z|X_i)} \left[\frac{1}{2\sigma^2} \vert\vert X_i - f_\theta(Z)\vert\vert^2\right] + D_{KL}(q_\phi (\cdot|X_i)||N(0, I))\] \[= \text{minimize}_{\theta \in\Theta, \phi \in \Phi} \sum_{i=1}^N \mathbb{E}_{Z_\sim q_{\phi}(z|X_i)} \left[\frac{1}{2\sigma^2} \vert\vert X_i - f_\theta(Z)\vert\vert^2\right] + \frac{1}{2}\left\{\text{tr}(\Sigma_\phi(X_i))+ \vert\vert \mu_\phi(X_i) \vert\vert^2 - d- \log {\mathrm{det}\Sigma_\phi(X_i)}\right\}\] \[= \text{minimize}_{\theta \in\Theta, \phi \in \Phi} \sum_{i=1}^N \mathbb{E}_{Z_\sim q_{\phi}(z|X_i)} \left[\frac{1}{\sigma^2} \vert\vert X_i - f_\theta(Z)\vert\vert^2\right] + \text{tr}(\Sigma_\phi(X_i))+ \vert\vert \mu_\phi(X_i) \vert\vert^2 - \log {\mathrm{det}\Sigma_\phi(X_i)}\] <p>로 바뀌게 된다. <br/> 트레이닝을 위해서는 위의 식을 \(\theta\)와 \(\phi\)에 대해 편미분하여 기울기를 구하고, 이를 통해 Stochastic Gradient Descent를 진행해야 하는데, 기댓값에 \(\theta\)와 \(\phi\)가 아랫첨자로 붙어있으니 기울기를 쉽게 구할수 없다. 위와 같이 기댓값의 기울기를 구해야 할 때 사용할 수 있는 방법으로는 <strong>reparametrization trick</strong>과 <strong>log-derivative trick</strong>(a.k.a. REINFORCE)이 있다. 여기서는 reparametrization trick을 사용해서 기울기를 구해본다.</p> <h2 id="reparametrization-trick">Reparametrization Trick</h2> <p>Reparametrization Trick에서는 \(Z_i\sim N(\mu_{\phi}(X_i), \Sigma_\phi(X_i))\)를 표준정규분포를 따르는 다른 확률변수 \(\epsilon_i \sim N(0, 1)\)를 사용해</p> \[Z_i = \mu_\phi (X_i) + \Sigma_{\phi}^{1/2}(X_i) \epsilon_i\] <p>와 같이 매개화한다. 여기서 \(\Sigma_\phi\) 는 대각행렬이며, 모든 성분이 0 이상이므로 각 성분에 제곱근을 취함으로써 \(\Sigma_\phi^{1/2}\)를 쉽게 구할 수 있다. 대입을 마치면 optimization objective는</p> \[\text{minimize}_{\theta \in\Theta, \phi \in \Phi} \sum_{i=1}^N \mathbb{E}_{\epsilon \sim N(0, 1)} \left[\frac{1}{\sigma^2} \vert\vert X_i - f_\theta(\mu_\phi(X_i) + \Sigma_\phi^{1/2}(X_i)\epsilon )\vert\vert^2\right] + \text{tr}(\Sigma_\phi(X_i))+ \vert\vert \mu_\phi(X_i) \vert\vert^2 - \log {\mathrm{det}\Sigma_\phi(X_i)}\] <p>로 바뀐다. 이제 기댓값이 \(\theta, \phi\)와는 무관한 식으로 바뀌었으므로 기댓값 안의 항을 미분하여 기울기를 쉽게 구하여 SGD를 시행할 수 있다.</p> <p>한편, 위의 식을 보면 loss가 크게</p> \[\frac{1}{\sigma^2}\mathbb{E}_{\epsilon \sim N(0, 1)} \left[\vert\vert X_i -f_\theta(\mu_\phi(X_i) + \Sigma_\phi^{1/2}(X_i)\epsilon)\vert\vert^2\right]\] <p>과</p> \[2D_{KL}(q_\phi(\cdot|X_i)\vert\vert p_z(\cdot)) = \text{tr}(\Sigma_\phi(X_i))+ \vert\vert \mu_\phi(X_i) \vert\vert^2 - \log {\mathrm{det}\Sigma_\phi(X_i)}\] <p>로 나눠지는 것을 알 수 있다. 전자를 자세히 보면 원래의 입력 이미지 \(X_i\)와, encoder와 decoder를 거쳐서 나온 reconstruct된 이미지 \(f_\theta(\mu_\phi(X_i) + \Sigma_\phi^{1/2}(X_i)\epsilon)\) 사이의 차이를 구하는 것이므로, <strong>reconstruction term</strong>라고 부를 수 있을 것이다. 후자의 경우 \(X_i\)를 latent space상으로 보내는 매핑이 일반적인 \(Z\)의 분포 \(N(0, I)\)과 너무 멀어지지 않도록 조절하는 역할을 하며, <strong>regularization term</strong>이라 명명될 수 있을 것이다.</p> <p>식을 보면 decoder의 출력에 더해주는 noise의 크기를 결정하는 \(\sigma\)가 두 term 사이의 가중치를 조절하는 hyperparameter의 역할을 하는 것을 알 수 있다.</p>]]></content><author><name></name></author><category term="deep-learning"/><category term="math"/><category term="MathDNN"/><summary type="html"><![CDATA[Variational Autoencoder의 수학적 기반]]></summary></entry></feed>